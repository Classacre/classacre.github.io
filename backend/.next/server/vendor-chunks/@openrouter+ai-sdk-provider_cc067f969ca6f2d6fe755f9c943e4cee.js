"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openrouter+ai-sdk-provider_cc067f969ca6f2d6fe755f9c943e4cee";
exports.ids = ["vendor-chunks/@openrouter+ai-sdk-provider_cc067f969ca6f2d6fe755f9c943e4cee"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@openrouter+ai-sdk-provider_cc067f969ca6f2d6fe755f9c943e4cee/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs":
/*!**************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@openrouter+ai-sdk-provider_cc067f969ca6f2d6fe755f9c943e4cee/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenRouter: () => (/* binding */ OpenRouter),\n/* harmony export */   createOpenRouter: () => (/* binding */ createOpenRouter),\n/* harmony export */   openrouter: () => (/* binding */ openrouter)\n/* harmony export */ });\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v4 */ \"(rsc)/../node_modules/.pnpm/zod@4.0.17/node_modules/zod/v4/classic/schemas.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// node_modules/.pnpm/@ai-sdk+provider@2.0.0/node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError2 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError2.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\n_a9 = symbol9;\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\n_a10 = symbol10;\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\n_a11 = symbol11;\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\n_a12 = symbol12;\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError2 extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/index.js\nvar ParseError = class extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n};\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\")\n    throw new TypeError(\n      \"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\"\n    );\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = true, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = false;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\", searchIndex = 0;\n  for (; searchIndex < chunk.length; ) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex), lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\n\n// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/stream.js\nvar EventSourceParserStream = class extends TransformStream {\n  constructor({ onError, onRetry, onComment } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          },\n          onError(error) {\n            onError === \"terminate\" ? controller.error(error) : typeof onError == \"function\" && onError(error);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js\nvar ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/array.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js\nvar ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\n\n// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),\n    {}\n  );\n}\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error;\n}\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n      rawValue: value\n    };\n  }\n}\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: __spreadValues({\n    \"Content-Type\": \"application/json\"\n  }, headers),\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nvar { btoa, atob } = globalThis;\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/schemas/reasoning-details.ts\n\nvar ReasoningDetailSummarySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.summary\" /* Summary */),\n  summary: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nvar ReasoningDetailEncryptedSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.encrypted\" /* Encrypted */),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nvar ReasoningDetailTextSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.text\" /* Text */),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n  signature: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish()\n});\nvar ReasoningDetailUnionSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ReasoningDetailSummarySchema,\n  ReasoningDetailEncryptedSchema,\n  ReasoningDetailTextSchema\n]);\nvar ReasoningDetailsWithUnknownSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ReasoningDetailUnionSchema,\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.unknown().transform(() => null)\n]);\nvar ReasoningDetailArraySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));\n\n// src/schemas/error-response.ts\n\nvar OpenRouterErrorResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  error: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    code: zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()]).nullable().optional().default(null),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional().default(null),\n    param: zod_v4__WEBPACK_IMPORTED_MODULE_0__.any().nullable().optional().default(null)\n  })\n});\nvar openrouterFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: OpenRouterErrorResponseSchema,\n  errorToMessage: (data) => data.error.message\n});\n\n// src/utils/map-finish-reason.ts\nfunction mapOpenRouterFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/chat/is-url.ts\nfunction isUrl({\n  url,\n  protocols\n}) {\n  try {\n    const urlObj = new URL(url);\n    return protocols.has(urlObj.protocol);\n  } catch (_) {\n    return false;\n  }\n}\n\n// src/chat/file-url-utils.ts\nfunction getFileUrl({\n  part,\n  defaultMediaType\n}) {\n  var _a15, _b;\n  if (part.data instanceof Uint8Array) {\n    const base64 = convertUint8ArrayToBase64(part.data);\n    return `data:${(_a15 = part.mediaType) != null ? _a15 : defaultMediaType};base64,${base64}`;\n  }\n  const stringUrl = part.data.toString();\n  if (isUrl({\n    url: stringUrl,\n    protocols: /* @__PURE__ */ new Set([\"http:\", \"https:\"])\n  })) {\n    return stringUrl;\n  }\n  return stringUrl.startsWith(\"data:\") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;\n}\n\n// src/chat/convert-to-openrouter-chat-messages.ts\nfunction getCacheControl(providerMetadata) {\n  var _a15, _b, _c;\n  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;\n  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;\n  return (_c = (_b = (_a15 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a15 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;\n}\nfunction convertToOpenRouterChatMessages(prompt) {\n  var _a15, _b, _c;\n  const messages = [];\n  for (const { role, content, providerOptions } of prompt) {\n    switch (role) {\n      case \"system\": {\n        messages.push({\n          role: \"system\",\n          content,\n          cache_control: getCacheControl(providerOptions)\n        });\n        break;\n      }\n      case \"user\": {\n        if (content.length === 1 && ((_a15 = content[0]) == null ? void 0 : _a15.type) === \"text\") {\n          const cacheControl = (_b = getCacheControl(providerOptions)) != null ? _b : getCacheControl(content[0].providerOptions);\n          const contentWithCacheControl = cacheControl ? [\n            {\n              type: \"text\",\n              text: content[0].text,\n              cache_control: cacheControl\n            }\n          ] : content[0].text;\n          messages.push({\n            role: \"user\",\n            content: contentWithCacheControl\n          });\n          break;\n        }\n        const messageCacheControl = getCacheControl(providerOptions);\n        const contentParts = content.map(\n          (part) => {\n            var _a16, _b2, _c2, _d, _e, _f;\n            const cacheControl = (_a16 = getCacheControl(part.providerOptions)) != null ? _a16 : messageCacheControl;\n            switch (part.type) {\n              case \"text\":\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  // For text parts, only use part-specific cache control\n                  cache_control: cacheControl\n                };\n              case \"file\": {\n                if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith(\"image/\")) {\n                  const url = getFileUrl({\n                    part,\n                    defaultMediaType: \"image/jpeg\"\n                  });\n                  return {\n                    type: \"image_url\",\n                    image_url: {\n                      url\n                    },\n                    // For image parts, use part-specific or message-level cache control\n                    cache_control: cacheControl\n                  };\n                }\n                const fileName = String(\n                  (_f = (_e = (_d = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d.filename) != null ? _e : part.filename) != null ? _f : \"\"\n                );\n                const fileData = getFileUrl({\n                  part,\n                  defaultMediaType: \"application/pdf\"\n                });\n                if (isUrl({\n                  url: fileData,\n                  protocols: /* @__PURE__ */ new Set([\"http:\", \"https:\"])\n                })) {\n                  return {\n                    type: \"file\",\n                    file: {\n                      filename: fileName,\n                      file_data: fileData\n                    }\n                  };\n                }\n                return {\n                  type: \"file\",\n                  file: {\n                    filename: fileName,\n                    file_data: fileData\n                  },\n                  cache_control: cacheControl\n                };\n              }\n              default: {\n                return {\n                  type: \"text\",\n                  text: \"\",\n                  cache_control: cacheControl\n                };\n              }\n            }\n          }\n        );\n        messages.push({\n          role: \"user\",\n          content: contentParts\n        });\n        break;\n      }\n      case \"assistant\": {\n        let text = \"\";\n        let reasoning = \"\";\n        const reasoningDetails = [];\n        const toolCalls = [];\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              text += part.text;\n              break;\n            }\n            case \"tool-call\": {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: \"function\",\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input)\n                }\n              });\n              break;\n            }\n            case \"reasoning\": {\n              reasoning += part.text;\n              reasoningDetails.push({\n                type: \"reasoning.text\" /* Text */,\n                text: part.text\n              });\n              break;\n            }\n            case \"file\":\n              break;\n            default: {\n              break;\n            }\n          }\n        }\n        messages.push({\n          role: \"assistant\",\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,\n          reasoning: reasoning || void 0,\n          reasoning_details: reasoningDetails.length > 0 ? reasoningDetails : void 0,\n          cache_control: getCacheControl(providerOptions)\n        });\n        break;\n      }\n      case \"tool\": {\n        for (const toolResponse of content) {\n          const content2 = getToolResultContent(toolResponse);\n          messages.push({\n            role: \"tool\",\n            tool_call_id: toolResponse.toolCallId,\n            content: content2,\n            cache_control: (_c = getCacheControl(providerOptions)) != null ? _c : getCacheControl(toolResponse.providerOptions)\n          });\n        }\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  return messages;\n}\nfunction getToolResultContent(input) {\n  return input.output.type === \"text\" ? input.output.value : JSON.stringify(input.output.value);\n}\n\n// src/chat/get-tool-choice.ts\n\nvar ChatCompletionToolChoiceSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"auto\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"none\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"required\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\"),\n    function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n    })\n  })\n]);\nfunction getChatCompletionToolChoice(toolChoice) {\n  switch (toolChoice.type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return toolChoice.type;\n    case \"tool\": {\n      return {\n        type: \"function\",\n        function: { name: toolChoice.toolName }\n      };\n    }\n    default: {\n      toolChoice;\n      throw new Error(`Invalid tool choice type: ${toolChoice}`);\n    }\n  }\n}\n\n// src/chat/schemas.ts\n\nvar OpenRouterChatCompletionBaseResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  model: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  provider: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  usage: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    prompt_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    prompt_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      cached_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n    }).nullish(),\n    completion_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    completion_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      reasoning_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n    }).nullish(),\n    total_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    cost_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      upstream_inference_cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish()\n    }).nullish()\n  }).nullish()\n});\nvar OpenRouterNonStreamChatCompletionResponseSchema = OpenRouterChatCompletionBaseResponseSchema.extend({\n  choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      message: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"assistant\"),\n        content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        reasoning_details: ReasoningDetailArraySchema.nullish(),\n        tool_calls: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional().nullable(),\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\"),\n            function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              arguments: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n            })\n          })\n        ).optional(),\n        annotations: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"url_citation\"]),\n            url_citation: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              end_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              start_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n            })\n          })\n        ).nullish()\n      }),\n      index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n      logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n            logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n            top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n              zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n              })\n            )\n          })\n        ).nullable()\n      }).nullable().optional(),\n      finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional().nullable()\n    })\n  )\n});\nvar OpenRouterStreamChatCompletionChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  OpenRouterChatCompletionBaseResponseSchema.extend({\n    choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          role: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"assistant\"]).optional(),\n          content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n          reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish().optional(),\n          reasoning_details: ReasoningDetailArraySchema.nullish(),\n          tool_calls: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n              id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\").optional(),\n              function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n                arguments: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish()\n              })\n            })\n          ).nullish(),\n          annotations: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"url_citation\"]),\n              url_citation: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                end_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n                start_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n              })\n            })\n          ).nullish()\n        }).nullish(),\n        logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n                zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                  token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                  logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n                })\n              )\n            })\n          ).nullable()\n        }).nullish(),\n        finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish()\n      })\n    )\n  }),\n  OpenRouterErrorResponseSchema\n]);\n\n// src/chat/index.ts\nvar OpenRouterChatLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v2\";\n    this.provider = \"openrouter\";\n    this.defaultObjectGenerationMode = \"tool\";\n    this.supportedUrls = {\n      \"image/*\": [\n        /^data:image\\/[a-zA-Z]+;base64,/,\n        /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i\n      ],\n      // 'text/*': [/^data:text\\//, /^https?:\\/\\/.+$/],\n      \"application/*\": [/^data:application\\//, /^https?:\\/\\/.+$/]\n    };\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    stopSequences,\n    responseFormat,\n    topK,\n    tools,\n    toolChoice\n  }) {\n    var _a15;\n    const baseArgs = __spreadValues(__spreadValues({\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === \"number\" ? true : void 0,\n      top_logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n      // messages:\n      messages: convertToOpenRouterChatMessages(prompt),\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning,\n      usage: this.settings.usage,\n      // Web search settings:\n      plugins: this.settings.plugins,\n      web_search_options: this.settings.web_search_options,\n      // Provider routing settings:\n      provider: this.settings.provider\n    }, this.config.extraBody), this.settings.extraBody);\n    if ((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null) {\n      return __spreadProps(__spreadValues({}, baseArgs), {\n        response_format: {\n          type: \"json_schema\",\n          json_schema: __spreadValues({\n            schema: responseFormat.schema,\n            strict: true,\n            name: (_a15 = responseFormat.name) != null ? _a15 : \"response\"\n          }, responseFormat.description && {\n            description: responseFormat.description\n          })\n        }\n      });\n    }\n    if (tools && tools.length > 0) {\n      const mappedTools = tools.filter((tool) => tool.type === \"function\").map((tool) => ({\n        type: \"function\",\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.inputSchema\n        }\n      }));\n      return __spreadProps(__spreadValues({}, baseArgs), {\n        tools: mappedTools,\n        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0\n      });\n    }\n    return baseArgs;\n  }\n  async doGenerate(options) {\n    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterNonStreamChatCompletionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error(\"No choice in response\");\n    }\n    const usageInfo = response.usage ? {\n      inputTokens: (_a15 = response.usage.prompt_tokens) != null ? _a15 : 0,\n      outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,\n      totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),\n      reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,\n      cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0\n    } : {\n      inputTokens: 0,\n      outputTokens: 0,\n      totalTokens: 0,\n      reasoningTokens: 0,\n      cachedInputTokens: 0\n    };\n    const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];\n    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {\n      switch (detail.type) {\n        case \"reasoning.text\" /* Text */: {\n          if (detail.text) {\n            return {\n              type: \"reasoning\",\n              text: detail.text\n            };\n          }\n          break;\n        }\n        case \"reasoning.summary\" /* Summary */: {\n          if (detail.summary) {\n            return {\n              type: \"reasoning\",\n              text: detail.summary\n            };\n          }\n          break;\n        }\n        case \"reasoning.encrypted\" /* Encrypted */: {\n          if (detail.data) {\n            return {\n              type: \"reasoning\",\n              text: \"[REDACTED]\"\n            };\n          }\n          break;\n        }\n        default: {\n          detail;\n        }\n      }\n      return null;\n    }).filter((p) => p !== null) : choice.message.reasoning ? [\n      {\n        type: \"reasoning\",\n        text: choice.message.reasoning\n      }\n    ] : [];\n    const content = [];\n    content.push(...reasoning);\n    if (choice.message.content) {\n      content.push({\n        type: \"text\",\n        text: choice.message.content\n      });\n    }\n    if (choice.message.tool_calls) {\n      for (const toolCall of choice.message.tool_calls) {\n        content.push({\n          type: \"tool-call\",\n          toolCallId: (_j = toolCall.id) != null ? _j : generateId(),\n          toolName: toolCall.function.name,\n          input: toolCall.function.arguments\n        });\n      }\n    }\n    if (choice.message.annotations) {\n      for (const annotation of choice.message.annotations) {\n        if (annotation.type === \"url_citation\") {\n          content.push({\n            type: \"source\",\n            sourceType: \"url\",\n            id: annotation.url_citation.url,\n            url: annotation.url_citation.url,\n            title: annotation.url_citation.title,\n            providerMetadata: {\n              openrouter: {\n                content: annotation.url_citation.content || \"\"\n              }\n            }\n          });\n        }\n      }\n    }\n    return {\n      content,\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: usageInfo,\n      warnings: [],\n      providerMetadata: {\n        openrouter: {\n          provider: (_k = response.provider) != null ? _k : \"\",\n          usage: {\n            promptTokens: (_l = usageInfo.inputTokens) != null ? _l : 0,\n            completionTokens: (_m = usageInfo.outputTokens) != null ? _m : 0,\n            totalTokens: (_n = usageInfo.totalTokens) != null ? _n : 0,\n            cost: (_o = response.usage) == null ? void 0 : _o.cost,\n            promptTokensDetails: {\n              cachedTokens: (_r = (_q = (_p = response.usage) == null ? void 0 : _p.prompt_tokens_details) == null ? void 0 : _q.cached_tokens) != null ? _r : 0\n            },\n            completionTokensDetails: {\n              reasoningTokens: (_u = (_t = (_s = response.usage) == null ? void 0 : _s.completion_tokens_details) == null ? void 0 : _t.reasoning_tokens) != null ? _u : 0\n            },\n            costDetails: {\n              upstreamInferenceCost: (_x = (_w = (_v = response.usage) == null ? void 0 : _v.cost_details) == null ? void 0 : _w.upstream_inference_cost) != null ? _x : 0\n            }\n          }\n        }\n      },\n      request: { body: args },\n      response: {\n        id: response.id,\n        modelId: response.model,\n        headers: responseHeaders\n      }\n    };\n  }\n  async doStream(options) {\n    var _a15;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: __spreadProps(__spreadValues({}, args), {\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? __spreadValues({\n          include_usage: true\n        }, ((_a15 = this.settings.usage) == null ? void 0 : _a15.include) ? { include_usage: true } : {}) : void 0\n      }),\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterStreamChatCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const toolCalls = [];\n    let finishReason = \"other\";\n    const usage = {\n      inputTokens: Number.NaN,\n      outputTokens: Number.NaN,\n      totalTokens: Number.NaN,\n      reasoningTokens: Number.NaN,\n      cachedInputTokens: Number.NaN\n    };\n    const openrouterUsage = {};\n    let textStarted = false;\n    let reasoningStarted = false;\n    let textId;\n    let reasoningId;\n    let openrouterResponseId;\n    let provider;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a16, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.provider) {\n              provider = value.provider;\n            }\n            if (value.id) {\n              openrouterResponseId = value.id;\n              controller.enqueue({\n                type: \"response-metadata\",\n                id: value.id\n              });\n            }\n            if (value.model) {\n              controller.enqueue({\n                type: \"response-metadata\",\n                modelId: value.model\n              });\n            }\n            if (value.usage != null) {\n              usage.inputTokens = value.usage.prompt_tokens;\n              usage.outputTokens = value.usage.completion_tokens;\n              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;\n                usage.cachedInputTokens = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens\n                };\n              }\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;\n                usage.reasoningTokens = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens\n                };\n              }\n              openrouterUsage.cost = value.usage.cost;\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.delta) == null) {\n              return;\n            }\n            const delta = choice.delta;\n            const emitReasoningChunk = (chunkText) => {\n              if (!reasoningStarted) {\n                reasoningId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: reasoningId\n                });\n                reasoningStarted = true;\n              }\n              controller.enqueue({\n                type: \"reasoning-delta\",\n                delta: chunkText,\n                id: reasoningId || generateId()\n              });\n            };\n            if (delta.reasoning_details && delta.reasoning_details.length > 0) {\n              for (const detail of delta.reasoning_details) {\n                switch (detail.type) {\n                  case \"reasoning.text\" /* Text */: {\n                    if (detail.text) {\n                      emitReasoningChunk(detail.text);\n                    }\n                    break;\n                  }\n                  case \"reasoning.encrypted\" /* Encrypted */: {\n                    if (detail.data) {\n                      emitReasoningChunk(\"[REDACTED]\");\n                    }\n                    break;\n                  }\n                  case \"reasoning.summary\" /* Summary */: {\n                    if (detail.summary) {\n                      emitReasoningChunk(detail.summary);\n                    }\n                    break;\n                  }\n                  default: {\n                    detail;\n                    break;\n                  }\n                }\n              }\n            } else if (delta.reasoning) {\n              emitReasoningChunk(delta.reasoning);\n            }\n            if (delta.content) {\n              if (reasoningStarted && !textStarted) {\n                controller.enqueue({\n                  type: \"reasoning-end\",\n                  id: reasoningId || generateId()\n                });\n                reasoningStarted = false;\n              }\n              if (!textStarted) {\n                textId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: \"text-start\",\n                  id: textId\n                });\n                textStarted = true;\n              }\n              controller.enqueue({\n                type: \"text-delta\",\n                delta: delta.content,\n                id: textId || generateId()\n              });\n            }\n            if (delta.annotations) {\n              for (const annotation of delta.annotations) {\n                if (annotation.type === \"url_citation\") {\n                  controller.enqueue({\n                    type: \"source\",\n                    sourceType: \"url\",\n                    id: annotation.url_citation.url,\n                    url: annotation.url_citation.url,\n                    title: annotation.url_citation.title,\n                    providerMetadata: {\n                      openrouter: {\n                        content: annotation.url_citation.content || \"\"\n                      }\n                    }\n                  });\n                }\n              }\n            }\n            if (delta.tool_calls != null) {\n              for (const toolCallDelta of delta.tool_calls) {\n                const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== \"function\") {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`\n                    });\n                  }\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`\n                    });\n                  }\n                  if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`\n                    });\n                  }\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: \"function\",\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: (_e = toolCallDelta.function.arguments) != null ? _e : \"\"\n                    },\n                    inputStarted: false,\n                    sent: false\n                  };\n                  const toolCall2 = toolCalls[index];\n                  if (toolCall2 == null) {\n                    throw new Error(\"Tool call is missing\");\n                  }\n                  if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson(toolCall2.function.arguments)) {\n                    toolCall2.inputStarted = true;\n                    controller.enqueue({\n                      type: \"tool-input-start\",\n                      id: toolCall2.id,\n                      toolName: toolCall2.function.name\n                    });\n                    controller.enqueue({\n                      type: \"tool-input-delta\",\n                      id: toolCall2.id,\n                      delta: toolCall2.function.arguments\n                    });\n                    controller.enqueue({\n                      type: \"tool-input-end\",\n                      id: toolCall2.id\n                    });\n                    controller.enqueue({\n                      type: \"tool-call\",\n                      toolCallId: toolCall2.id,\n                      toolName: toolCall2.function.name,\n                      input: toolCall2.function.arguments\n                    });\n                    toolCall2.sent = true;\n                  }\n                  continue;\n                }\n                const toolCall = toolCalls[index];\n                if (toolCall == null) {\n                  throw new Error(\"Tool call is missing\");\n                }\n                if (!toolCall.inputStarted) {\n                  toolCall.inputStarted = true;\n                  controller.enqueue({\n                    type: \"tool-input-start\",\n                    id: toolCall.id,\n                    toolName: toolCall.function.name\n                  });\n                }\n                if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {\n                  toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : \"\";\n                }\n                controller.enqueue({\n                  type: \"tool-input-delta\",\n                  id: toolCall.id,\n                  delta: (_k = toolCallDelta.function.arguments) != null ? _k : \"\"\n                });\n                if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson(toolCall.function.arguments)) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallId: (_n = toolCall.id) != null ? _n : generateId(),\n                    toolName: toolCall.function.name,\n                    input: toolCall.function.arguments\n                  });\n                  toolCall.sent = true;\n                }\n              }\n            }\n          },\n          flush(controller) {\n            var _a16;\n            if (finishReason === \"tool-calls\") {\n              for (const toolCall of toolCalls) {\n                if (toolCall && !toolCall.sent) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallId: (_a16 = toolCall.id) != null ? _a16 : generateId(),\n                    toolName: toolCall.function.name,\n                    // Coerce invalid arguments to an empty JSON object\n                    input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : \"{}\"\n                  });\n                  toolCall.sent = true;\n                }\n              }\n            }\n            if (reasoningStarted) {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: reasoningId || generateId()\n              });\n            }\n            if (textStarted) {\n              controller.enqueue({\n                type: \"text-end\",\n                id: textId || generateId()\n              });\n            }\n            const openrouterMetadata = {\n              usage: openrouterUsage\n            };\n            if (provider !== void 0) {\n              openrouterMetadata.provider = provider;\n            }\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: openrouterMetadata\n              }\n            });\n          }\n        })\n      ),\n      warnings: [],\n      request: { body: args },\n      response: { headers: responseHeaders }\n    };\n  }\n};\n\n// src/completion/convert-to-openrouter-completion-prompt.ts\nfunction convertToOpenRouterCompletionPrompt({\n  prompt,\n  inputFormat,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  if (inputFormat === \"prompt\" && prompt.length === 1 && prompt[0] && prompt[0].role === \"user\" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === \"text\") {\n    return { prompt: prompt[0].content[0].text };\n  }\n  let text = \"\";\n  if (prompt[0] && prompt[0].role === \"system\") {\n    text += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        throw new InvalidPromptError({\n          message: `Unexpected system message in prompt: ${content}`,\n          prompt\n        });\n      }\n      case \"user\": {\n        const userMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"file\": {\n              throw new UnsupportedFunctionalityError({\n                functionality: \"file attachments\"\n              });\n            }\n            default: {\n              return \"\";\n            }\n          }\n        }).join(\"\");\n        text += `${user}:\n${userMessage}\n\n`;\n        break;\n      }\n      case \"assistant\": {\n        const assistantMessage = content.map(\n          (part) => {\n            switch (part.type) {\n              case \"text\": {\n                return part.text;\n              }\n              case \"tool-call\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"tool-call messages\"\n                });\n              }\n              case \"tool-result\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"tool-result messages\"\n                });\n              }\n              case \"reasoning\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"reasoning messages\"\n                });\n              }\n              case \"file\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"file attachments\"\n                });\n              }\n              default: {\n                return \"\";\n              }\n            }\n          }\n        ).join(\"\");\n        text += `${assistant}:\n${assistantMessage}\n\n`;\n        break;\n      }\n      case \"tool\": {\n        throw new UnsupportedFunctionalityError({\n          functionality: \"tool messages\"\n        });\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  text += `${assistant}:\n`;\n  return {\n    prompt: text\n  };\n}\n\n// src/completion/schemas.ts\n\nvar OpenRouterCompletionChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    model: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        text: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n        reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish().optional(),\n        reasoning_details: ReasoningDetailArraySchema.nullish(),\n        finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n        index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n        logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()),\n          token_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()),\n          top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.record(zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_0__.number())).nullable()\n        }).nullable().optional()\n      })\n    ),\n    usage: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      prompt_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      prompt_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        cached_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n      }).nullish(),\n      completion_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      completion_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        reasoning_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n      }).nullish(),\n      total_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().optional()\n    }).nullish()\n  }),\n  OpenRouterErrorResponseSchema\n]);\n\n// src/completion/index.ts\nvar OpenRouterCompletionLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v2\";\n    this.provider = \"openrouter\";\n    this.supportedUrls = {\n      \"image/*\": [\n        /^data:image\\/[a-zA-Z]+;base64,/,\n        /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i\n      ],\n      \"text/*\": [/^data:text\\//, /^https?:\\/\\/.+$/],\n      \"application/*\": [/^data:application\\//, /^https?:\\/\\/.+$/]\n    };\n    this.defaultObjectGenerationMode = void 0;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    responseFormat,\n    topK,\n    stopSequences,\n    tools,\n    toolChoice\n  }) {\n    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({\n      prompt,\n      inputFormat: \"prompt\"\n    });\n    if (tools == null ? void 0 : tools.length) {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"tools\"\n      });\n    }\n    if (toolChoice) {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"toolChoice\"\n      });\n    }\n    return __spreadValues(__spreadValues({\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n      // prompt:\n      prompt: completionPrompt,\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning\n    }, this.config.extraBody), this.settings.extraBody);\n  }\n  async doGenerate(options) {\n    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    if (\"error\" in response) {\n      throw new Error(`${response.error.message}`);\n    }\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error(\"No choice in OpenRouter completion response\");\n    }\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: (_a15 = choice.text) != null ? _a15 : \"\"\n        }\n      ],\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: {\n        inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,\n        outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,\n        totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),\n        reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,\n        cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0\n      },\n      warnings: [],\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n  async doStream(options) {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: __spreadProps(__spreadValues({}, args), {\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n      }),\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    let finishReason = \"other\";\n    const usage = {\n      inputTokens: Number.NaN,\n      outputTokens: Number.NaN,\n      totalTokens: Number.NaN,\n      reasoningTokens: Number.NaN,\n      cachedInputTokens: Number.NaN\n    };\n    const openrouterUsage = {};\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a15, _b;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.usage != null) {\n              usage.inputTokens = value.usage.prompt_tokens;\n              usage.outputTokens = value.usage.completion_tokens;\n              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens = (_a15 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a15 : 0;\n                usage.cachedInputTokens = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens\n                };\n              }\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;\n                usage.reasoningTokens = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens\n                };\n              }\n              openrouterUsage.cost = value.usage.cost;\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.text) != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                delta: choice.text,\n                id: generateId()\n              });\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: {\n                  usage: openrouterUsage\n                }\n              }\n            });\n          }\n        })\n      ),\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\n\n// src/facade.ts\nvar OpenRouter = class {\n  /**\n   * Creates a new OpenRouter provider instance.\n   */\n  constructor(options = {}) {\n    var _a15, _b;\n    this.baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : \"https://openrouter.ai/api/v1\";\n    this.apiKey = options.apiKey;\n    this.headers = options.headers;\n  }\n  get baseConfig() {\n    return {\n      baseURL: this.baseURL,\n      headers: () => __spreadValues({\n        Authorization: `Bearer ${loadApiKey({\n          apiKey: this.apiKey,\n          environmentVariableName: \"OPENROUTER_API_KEY\",\n          description: \"OpenRouter\"\n        })}`\n      }, this.headers)\n    };\n  }\n  chat(modelId, settings = {}) {\n    return new OpenRouterChatLanguageModel(modelId, settings, __spreadProps(__spreadValues({\n      provider: \"openrouter.chat\"\n    }, this.baseConfig), {\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    }));\n  }\n  completion(modelId, settings = {}) {\n    return new OpenRouterCompletionLanguageModel(modelId, settings, __spreadProps(__spreadValues({\n      provider: \"openrouter.completion\"\n    }, this.baseConfig), {\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    }));\n  }\n};\n\n// src/provider.ts\nfunction createOpenRouter(options = {}) {\n  var _a15, _b, _c;\n  const baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : \"https://openrouter.ai/api/v1\";\n  const compatibility = (_c = options.compatibility) != null ? _c : \"compatible\";\n  const getHeaders = () => __spreadValues({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: \"OPENROUTER_API_KEY\",\n      description: \"OpenRouter\"\n    })}`\n  }, options.headers);\n  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {\n    provider: \"openrouter.chat\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch,\n    extraBody: options.extraBody\n  });\n  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {\n    provider: \"openrouter.completion\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch,\n    extraBody: options.extraBody\n  });\n  const createLanguageModel = (modelId, settings) => {\n    if (new.target) {\n      throw new Error(\n        \"The OpenRouter model function cannot be called with the new keyword.\"\n      );\n    }\n    if (modelId === \"openai/gpt-3.5-turbo-instruct\") {\n      return createCompletionModel(\n        modelId,\n        settings\n      );\n    }\n    return createChatModel(modelId, settings);\n  };\n  const provider = (modelId, settings) => createLanguageModel(modelId, settings);\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  return provider;\n}\nvar openrouter = createOpenRouter({\n  compatibility: \"strict\"\n  // strict for OpenRouter API\n});\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVucm91dGVyK2FpLXNkay1wcm92aWRlcl9jYzA2N2Y5NjljYTZmMmQ2ZmU3NTVmOWM5NDNlNGNlZS9ub2RlX21vZHVsZXMvQG9wZW5yb3V0ZXIvYWktc2RrLXByb3ZpZGVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsSUFBSTtBQUN0RCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUCxHQUFHO0FBQ0gsaURBQWlEO0FBQ2pEO0FBQ0EsWUFBWSxNQUFNLFFBQVEsUUFBUSxFQUFFLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdURBQXVEO0FBQ3ZEO0FBQ0EsWUFBWSxNQUFNLFFBQVEsUUFBUSxFQUFFLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFLQztBQUNGIiwic291cmNlcyI6WyJEOlxcQUlcXEJpb0luZmluYSBXZWJzaXRlXFxjbGFzc2FjcmUuZ2l0aHViLmlvXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAb3BlbnJvdXRlcithaS1zZGstcHJvdmlkZXJfY2MwNjdmOTY5Y2E2ZjJkNmZlNzU1ZjljOTQzZTRjZWVcXG5vZGVfbW9kdWxlc1xcQG9wZW5yb3V0ZXJcXGFpLXNkay1wcm92aWRlclxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQGFpLXNkaytwcm92aWRlckAyLjAuMC9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qc1xudmFyIG1hcmtlciA9IFwidmVyY2VsLmFpLmVycm9yXCI7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIF9BSVNES0Vycm9yID0gY2xhc3MgX0FJU0RLRXJyb3IyIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbiAgc3RhdGljIGhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpIHtcbiAgICBjb25zdCBtYXJrZXJTeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbiAgICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgbWFya2VyU3ltYm9sIGluIGVycm9yICYmIHR5cGVvZiBlcnJvclttYXJrZXJTeW1ib2xdID09PSBcImJvb2xlYW5cIiAmJiBlcnJvclttYXJrZXJTeW1ib2xdID09PSB0cnVlO1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG52YXIgQUlTREtFcnJvciA9IF9BSVNES0Vycm9yO1xudmFyIG5hbWUgPSBcIkFJX0FQSUNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBBUElDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICB1cmwsXG4gICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgcmVzcG9uc2VCb2R5LFxuICAgIGNhdXNlLFxuICAgIGlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSAhPSBudWxsICYmIChzdGF0dXNDb2RlID09PSA0MDggfHwgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDA5IHx8IC8vIGNvbmZsaWN0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDI5IHx8IC8vIHRvbyBtYW55IHJlcXVlc3RzXG4gICAgc3RhdHVzQ29kZSA+PSA1MDApLFxuICAgIC8vIHNlcnZlciBlcnJvclxuICAgIGRhdGFcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzID0gcmVxdWVzdEJvZHlWYWx1ZXM7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlQm9keSA9IHJlc3BvbnNlQm9keTtcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gaXNSZXRyeWFibGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xudmFyIG5hbWUyID0gXCJBSV9FbXB0eVJlc3BvbnNlQm9keUVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBFbXB0eVJlc3BvbnNlQm9keUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiRW1wdHkgcmVzcG9uc2UgYm9keVwiIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZSxcbiAgICBhcmd1bWVudFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjQpO1xuICB9XG59O1xuX2E0ID0gc3ltYm9sNDtcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZFByb21wdEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBJbnZhbGlkUHJvbXB0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2U6IGBJbnZhbGlkIHByb21wdDogJHttZXNzYWdlfWAsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcbnZhciBuYW1lNSA9IFwiQUlfSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgcmVzcG9uc2UgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcbnZhciBuYW1lNiA9IFwiQUlfSlNPTlBhcnNlRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIEpTT05QYXJzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB0ZXh0LCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTYsXG4gICAgICBtZXNzYWdlOiBgSlNPTiBwYXJzaW5nIGZhaWxlZDogVGV4dDogJHt0ZXh0fS5cbkVycm9yIG1lc3NhZ2U6ICR7Z2V0RXJyb3JNZXNzYWdlKGNhdXNlKX1gLFxuICAgICAgY2F1c2VcbiAgICB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcbnZhciBuYW1lNyA9IFwiQUlfTG9hZEFQSUtleUVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBMb2FkQVBJS2V5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcbnZhciBuYW1lOCA9IFwiQUlfTG9hZFNldHRpbmdFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG5fYTkgPSBzeW1ib2w5O1xudmFyIG5hbWU5ID0gXCJBSV9Ob0NvbnRlbnRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xuX2ExMCA9IHN5bWJvbDEwO1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbl9hMTEgPSBzeW1ib2wxMTtcbnZhciBuYW1lMTEgPSBcIkFJX1Rvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG5fYTEyID0gc3ltYm9sMTI7XG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IyIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdmFsdWUsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTIsXG4gICAgICBtZXNzYWdlOiBgVHlwZSB2YWxpZGF0aW9uIGZhaWxlZDogVmFsdWU6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS5cbkVycm9yIG1lc3NhZ2U6ICR7Z2V0RXJyb3JNZXNzYWdlKGNhdXNlKX1gLFxuICAgICAgY2F1c2VcbiAgICB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxuICAvKipcbiAgICogV3JhcHMgYW4gZXJyb3IgaW50byBhIFR5cGVWYWxpZGF0aW9uRXJyb3IuXG4gICAqIElmIHRoZSBjYXVzZSBpcyBhbHJlYWR5IGEgVHlwZVZhbGlkYXRpb25FcnJvciB3aXRoIHRoZSBzYW1lIHZhbHVlLCBpdCByZXR1cm5zIHRoZSBjYXVzZS5cbiAgICogT3RoZXJ3aXNlLCBpdCBjcmVhdGVzIGEgbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3Igd3JhcHBpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBhcmFtcy52YWx1ZSAtIFRoZSB2YWx1ZSB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBhcmFtcy5jYXVzZSAtIFRoZSBvcmlnaW5hbCBlcnJvciBvciBjYXVzZSBvZiB0aGUgdmFsaWRhdGlvbiBmYWlsdXJlLlxuICAgKiBAcmV0dXJucyB7VHlwZVZhbGlkYXRpb25FcnJvcn0gQSBUeXBlVmFsaWRhdGlvbkVycm9yIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoe1xuICAgIHZhbHVlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICByZXR1cm4gX1R5cGVWYWxpZGF0aW9uRXJyb3IyLmlzSW5zdGFuY2UoY2F1c2UpICYmIGNhdXNlLnZhbHVlID09PSB2YWx1ZSA/IGNhdXNlIDogbmV3IF9UeXBlVmFsaWRhdGlvbkVycm9yMih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG52YXIgbmFtZTEzID0gXCJBSV9VbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclwiO1xudmFyIG1hcmtlcjE0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDE0ID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG52YXIgX2ExNDtcbnZhciBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBmdW5jdGlvbmFsaXR5LFxuICAgIG1lc3NhZ2UgPSBgJyR7ZnVuY3Rpb25hbGl0eX0nIGZ1bmN0aW9uYWxpdHkgbm90IHN1cHBvcnRlZC5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTRdID0gdHJ1ZTtcbiAgICB0aGlzLmZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbmFsaXR5O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNCk7XG4gIH1cbn07XG5fYTE0ID0gc3ltYm9sMTQ7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9ldmVudHNvdXJjZS1wYXJzZXJAMy4wLjMvbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlLXBhcnNlci9kaXN0L2luZGV4LmpzXG52YXIgUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSksIHRoaXMubmFtZSA9IFwiUGFyc2VFcnJvclwiLCB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUsIHRoaXMuZmllbGQgPSBvcHRpb25zLmZpZWxkLCB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZSwgdGhpcy5saW5lID0gb3B0aW9ucy5saW5lO1xuICB9XG59O1xuZnVuY3Rpb24gbm9vcChfYXJnKSB7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIoY2FsbGJhY2tzKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2tzID09IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJgY2FsbGJhY2tzYCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IGEgZnVuY3Rpb24gaW5zdGVhZC4gRGlkIHlvdSBtZWFuIGB7b25FdmVudDogZm59YD9cIlxuICAgICk7XG4gIGNvbnN0IHsgb25FdmVudCA9IG5vb3AsIG9uRXJyb3IgPSBub29wLCBvblJldHJ5ID0gbm9vcCwgb25Db21tZW50IH0gPSBjYWxsYmFja3M7XG4gIGxldCBpbmNvbXBsZXRlTGluZSA9IFwiXCIsIGlzRmlyc3RDaHVuayA9IHRydWUsIGlkLCBkYXRhID0gXCJcIiwgZXZlbnRUeXBlID0gXCJcIjtcbiAgZnVuY3Rpb24gZmVlZChuZXdDaHVuaykge1xuICAgIGNvbnN0IGNodW5rID0gaXNGaXJzdENodW5rID8gbmV3Q2h1bmsucmVwbGFjZSgvXlxceEVGXFx4QkJcXHhCRi8sIFwiXCIpIDogbmV3Q2h1bmssIFtjb21wbGV0ZSwgaW5jb21wbGV0ZV0gPSBzcGxpdExpbmVzKGAke2luY29tcGxldGVMaW5lfSR7Y2h1bmt9YCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGNvbXBsZXRlKVxuICAgICAgcGFyc2VMaW5lKGxpbmUpO1xuICAgIGluY29tcGxldGVMaW5lID0gaW5jb21wbGV0ZSwgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VMaW5lKGxpbmUpIHtcbiAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgZGlzcGF0Y2hFdmVudCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgICAgb25Db21tZW50ICYmIG9uQ29tbWVudChsaW5lLnNsaWNlKGxpbmUuc3RhcnRzV2l0aChcIjogXCIpID8gMiA6IDEpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmllbGRTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGZpZWxkU2VwYXJhdG9ySW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgZmllbGRTZXBhcmF0b3JJbmRleCksIG9mZnNldCA9IGxpbmVbZmllbGRTZXBhcmF0b3JJbmRleCArIDFdID09PSBcIiBcIiA/IDIgOiAxLCB2YWx1ZSA9IGxpbmUuc2xpY2UoZmllbGRTZXBhcmF0b3JJbmRleCArIG9mZnNldCk7XG4gICAgICBwcm9jZXNzRmllbGQoZmllbGQsIHZhbHVlLCBsaW5lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzc0ZpZWxkKGxpbmUsIFwiXCIsIGxpbmUpO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChmaWVsZCwgdmFsdWUsIGxpbmUpIHtcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgZXZlbnRUeXBlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgZGF0YSA9IGAke2RhdGF9JHt2YWx1ZX1cbmA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIGlkID0gdmFsdWUuaW5jbHVkZXMoXCJcXDBcIikgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmV0cnlcIjpcbiAgICAgICAgL15cXGQrJC8udGVzdCh2YWx1ZSkgPyBvblJldHJ5KHBhcnNlSW50KHZhbHVlLCAxMCkpIDogb25FcnJvcihcbiAgICAgICAgICBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBcXGByZXRyeVxcYCB2YWx1ZTogXCIke3ZhbHVlfVwiYCwge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkLXJldHJ5XCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBgVW5rbm93biBmaWVsZCBcIiR7ZmllbGQubGVuZ3RoID4gMjAgPyBgJHtmaWVsZC5zbGljZSgwLCAyMCl9XFx1MjAyNmAgOiBmaWVsZH1cImAsXG4gICAgICAgICAgICB7IHR5cGU6IFwidW5rbm93bi1maWVsZFwiLCBmaWVsZCwgdmFsdWUsIGxpbmUgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgZGF0YS5sZW5ndGggPiAwICYmIG9uRXZlbnQoe1xuICAgICAgaWQsXG4gICAgICBldmVudDogZXZlbnRUeXBlIHx8IHZvaWQgMCxcbiAgICAgIC8vIElmIHRoZSBkYXRhIGJ1ZmZlcidzIGxhc3QgY2hhcmFjdGVyIGlzIGEgVSswMDBBIExJTkUgRkVFRCAoTEYpIGNoYXJhY3RlcixcbiAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBmcm9tIHRoZSBkYXRhIGJ1ZmZlci5cbiAgICAgIGRhdGE6IGRhdGEuZW5kc1dpdGgoYFxuYCkgPyBkYXRhLnNsaWNlKDAsIC0xKSA6IGRhdGFcbiAgICB9KSwgaWQgPSB2b2lkIDAsIGRhdGEgPSBcIlwiLCBldmVudFR5cGUgPSBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KG9wdGlvbnMgPSB7fSkge1xuICAgIGluY29tcGxldGVMaW5lICYmIG9wdGlvbnMuY29uc3VtZSAmJiBwYXJzZUxpbmUoaW5jb21wbGV0ZUxpbmUpLCBpc0ZpcnN0Q2h1bmsgPSB0cnVlLCBpZCA9IHZvaWQgMCwgZGF0YSA9IFwiXCIsIGV2ZW50VHlwZSA9IFwiXCIsIGluY29tcGxldGVMaW5lID0gXCJcIjtcbiAgfVxuICByZXR1cm4geyBmZWVkLCByZXNldCB9O1xufVxuZnVuY3Rpb24gc3BsaXRMaW5lcyhjaHVuaykge1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBsZXQgaW5jb21wbGV0ZUxpbmUgPSBcIlwiLCBzZWFyY2hJbmRleCA9IDA7XG4gIGZvciAoOyBzZWFyY2hJbmRleCA8IGNodW5rLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgY3JJbmRleCA9IGNodW5rLmluZGV4T2YoXCJcXHJcIiwgc2VhcmNoSW5kZXgpLCBsZkluZGV4ID0gY2h1bmsuaW5kZXhPZihgXG5gLCBzZWFyY2hJbmRleCk7XG4gICAgbGV0IGxpbmVFbmQgPSAtMTtcbiAgICBpZiAoY3JJbmRleCAhPT0gLTEgJiYgbGZJbmRleCAhPT0gLTEgPyBsaW5lRW5kID0gTWF0aC5taW4oY3JJbmRleCwgbGZJbmRleCkgOiBjckluZGV4ICE9PSAtMSA/IGxpbmVFbmQgPSBjckluZGV4IDogbGZJbmRleCAhPT0gLTEgJiYgKGxpbmVFbmQgPSBsZkluZGV4KSwgbGluZUVuZCA9PT0gLTEpIHtcbiAgICAgIGluY29tcGxldGVMaW5lID0gY2h1bmsuc2xpY2Uoc2VhcmNoSW5kZXgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBjaHVuay5zbGljZShzZWFyY2hJbmRleCwgbGluZUVuZCk7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUpLCBzZWFyY2hJbmRleCA9IGxpbmVFbmQgKyAxLCBjaHVua1tzZWFyY2hJbmRleCAtIDFdID09PSBcIlxcclwiICYmIGNodW5rW3NlYXJjaEluZGV4XSA9PT0gYFxuYCAmJiBzZWFyY2hJbmRleCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2xpbmVzLCBpbmNvbXBsZXRlTGluZV07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9ldmVudHNvdXJjZS1wYXJzZXJAMy4wLjMvbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlLXBhcnNlci9kaXN0L3N0cmVhbS5qc1xudmFyIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcih7IG9uRXJyb3IsIG9uUmV0cnksIG9uQ29tbWVudCB9ID0ge30pIHtcbiAgICBsZXQgcGFyc2VyO1xuICAgIHN1cGVyKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcGFyc2VyID0gY3JlYXRlUGFyc2VyKHtcbiAgICAgICAgICBvbkV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShldmVudCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yID09PSBcInRlcm1pbmF0ZVwiID8gY29udHJvbGxlci5lcnJvcihlcnJvcikgOiB0eXBlb2Ygb25FcnJvciA9PSBcImZ1bmN0aW9uXCIgJiYgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblJldHJ5LFxuICAgICAgICAgIG9uQ29tbWVudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgICAgcGFyc2VyLmZlZWQoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQGFpLXNkaytwcm92aWRlci11dGlsc0AzLjAuMV96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qc1xuaW1wb3J0ICogYXMgejQgZnJvbSBcInpvZC92NFwiO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kLXRvLWpzb24tc2NoZW1hQDMuMjQuNl96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL09wdGlvbnMuanNcbnZhciBpZ25vcmVPdmVycmlkZSA9IFN5bWJvbChcIkxldCB6b2RUb0pzb25TY2hlbWEgZGVjaWRlIG9uIHdoaWNoIHBhcnNlciB0byB1c2VcIik7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2QtdG8tanNvbi1zY2hlbWFAMy4yNC42X3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vc2VsZWN0UGFyc2VyLmpzXG5pbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgYXMgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMyB9IGZyb20gXCJ6b2RcIjtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZC10by1qc29uLXNjaGVtYUAzLjI0LjZfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2FycmF5LmpzXG5pbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgfSBmcm9tIFwiem9kXCI7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2QtdG8tanNvbi1zY2hlbWFAMy4yNC42X3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9yZWNvcmQuanNcbmltcG9ydCB7IFpvZEZpcnN0UGFydHlUeXBlS2luZCBhcyBab2RGaXJzdFBhcnR5VHlwZUtpbmQyIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kLXRvLWpzb24tc2NoZW1hQDMuMjQuNl96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvc3RyaW5nLmpzXG52YXIgQUxQSEFfTlVNRVJJQyA9IG5ldyBTZXQoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnh5ejAxMjM0NTY3ODlcIik7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9AYWktc2RrK3Byb3ZpZGVyLXV0aWxzQDMuMC4xX3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyLXV0aWxzL2Rpc3QvaW5kZXgubWpzXG5mdW5jdGlvbiBjb21iaW5lSGVhZGVycyguLi5oZWFkZXJzKSB7XG4gIHJldHVybiBoZWFkZXJzLnJlZHVjZShcbiAgICAoY29tYmluZWRIZWFkZXJzLCBjdXJyZW50SGVhZGVycykgPT4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGNvbWJpbmVkSGVhZGVycyksIGN1cnJlbnRIZWFkZXJzICE9IG51bGwgPyBjdXJyZW50SGVhZGVycyA6IHt9KSxcbiAgICB7fVxuICApO1xufVxuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFsuLi5yZXNwb25zZS5oZWFkZXJzXSk7XG59XG52YXIgY3JlYXRlSWRHZW5lcmF0b3IgPSAoe1xuICBwcmVmaXgsXG4gIHNpemUgPSAxNixcbiAgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIHNlcGFyYXRvciA9IFwiLVwiXG59ID0ge30pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IGFscGhhYmV0TGVuZ3RoID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIGNvbnN0IGNoYXJzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBhbHBoYWJldExlbmd0aCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbihcIlwiKTtcbiAgfTtcbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBpZiAoYWxwaGFiZXQuaW5jbHVkZXMoc2VwYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBhcmd1bWVudDogXCJzZXBhcmF0b3JcIixcbiAgICAgIG1lc3NhZ2U6IGBUaGUgc2VwYXJhdG9yIFwiJHtzZXBhcmF0b3J9XCIgbXVzdCBub3QgYmUgcGFydCBvZiB0aGUgYWxwaGFiZXQgXCIke2FscGhhYmV0fVwiLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKCkgPT4gYCR7cHJlZml4fSR7c2VwYXJhdG9yfSR7Z2VuZXJhdG9yKCl9YDtcbn07XG52YXIgZ2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCk7XG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSAmJiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IubmFtZSA9PT0gXCJSZXNwb25zZUFib3J0ZWRcIiB8fCAvLyBOZXh0LmpzXG4gIGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpO1xufVxudmFyIEZFVENIX0ZBSUxFRF9FUlJPUl9NRVNTQUdFUyA9IFtcImZldGNoIGZhaWxlZFwiLCBcImZhaWxlZCB0byBmZXRjaFwiXTtcbmZ1bmN0aW9uIGhhbmRsZUZldGNoRXJyb3Ioe1xuICBlcnJvcixcbiAgdXJsLFxuICByZXF1ZXN0Qm9keVZhbHVlc1xufSkge1xuICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgRkVUQ0hfRkFJTEVEX0VSUk9SX01FU1NBR0VTLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKSkpIHtcbiAgICBjb25zdCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgIGlmIChjYXVzZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7Y2F1c2UubWVzc2FnZX1gLFxuICAgICAgICBjYXVzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgaXNSZXRyeWFibGU6IHRydWVcbiAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cbnZhciBzdXNwZWN0UHJvdG9SeCA9IC9cIl9fcHJvdG9fX1wiXFxzKjovO1xudmFyIHN1c3BlY3RDb25zdHJ1Y3RvclJ4ID0gL1wiY29uc3RydWN0b3JcIlxccyo6LztcbmZ1bmN0aW9uIF9wYXJzZSh0ZXh0KSB7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UodGV4dCk7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKHN1c3BlY3RQcm90b1J4LnRlc3QodGV4dCkgPT09IGZhbHNlICYmIHN1c3BlY3RDb25zdHJ1Y3RvclJ4LnRlc3QodGV4dCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gZmlsdGVyKG9iaik7XG59XG5mdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gIGxldCBuZXh0ID0gW29ial07XG4gIHdoaWxlIChuZXh0Lmxlbmd0aCkge1xuICAgIGNvbnN0IG5vZGVzID0gbmV4dDtcbiAgICBuZXh0ID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIFwiX19wcm90b19fXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk9iamVjdCBjb250YWlucyBmb3JiaWRkZW4gcHJvdG90eXBlIHByb3BlcnR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcImNvbnN0cnVjdG9yXCIpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLmNvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJPYmplY3QgY29udGFpbnMgZm9yYmlkZGVuIHByb3RvdHlwZSBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBuZXh0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBzZWN1cmVKc29uUGFyc2UodGV4dCkge1xuICBjb25zdCB7IHN0YWNrVHJhY2VMaW1pdCB9ID0gRXJyb3I7XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9wYXJzZSh0ZXh0KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gIH1cbn1cbnZhciB2YWxpZGF0b3JTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnZhbGlkYXRvclwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRvcih2YWxpZGF0ZSkge1xuICByZXR1cm4geyBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSwgdmFsaWRhdGUgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsaWRhdG9yU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3ZhbGlkYXRvclN5bWJvbF0gPT09IHRydWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzVmFsaWRhdG9yKHZhbHVlKSA/IHZhbHVlIDogc3RhbmRhcmRTY2hlbWFWYWxpZGF0b3IodmFsdWUpO1xufVxuZnVuY3Rpb24gc3RhbmRhcmRTY2hlbWFWYWxpZGF0b3Ioc3RhbmRhcmRTY2hlbWEpIHtcbiAgcmV0dXJuIHZhbGlkYXRvcihhc3luYyAodmFsdWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGFuZGFyZFNjaGVtYVtcIn5zdGFuZGFyZFwiXS52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMgPT0gbnVsbCA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC52YWx1ZSB9IDoge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2F1c2U6IHJlc3VsdC5pc3N1ZXNcbiAgICAgIH0pXG4gICAgfTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hXG59KSB7XG4gIGNvbnN0IHZhbGlkYXRvcjIgPSBhc1ZhbGlkYXRvcihzY2hlbWEpO1xuICB0cnkge1xuICAgIGlmICh2YWxpZGF0b3IyLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yMi52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LnZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pLFxuICAgICAgcmF3VmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiBlcnJvciB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gc2VjdXJlSnNvblBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNhZmVQYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNlY3VyZUpzb25QYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgPyBlcnJvciA6IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnNhYmxlSnNvbihpbnB1dCkge1xuICB0cnkge1xuICAgIHNlY3VyZUpzb25QYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSnNvbkV2ZW50U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBzY2hlbWFcbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2gobmV3IEV2ZW50U291cmNlUGFyc2VyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChkYXRhID09PSBcIltET05FXVwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShhd2FpdCBzYWZlUGFyc2VKU09OKHsgdGV4dDogZGF0YSwgc2NoZW1hIH0pKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBwb3N0SnNvblRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgfSwgaGVhZGVycyksXG4gIGJvZHk6IHtcbiAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB2YWx1ZXM6IGJvZHlcbiAgfSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pO1xudmFyIHBvc3RUb0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyA9IHt9LFxuICBib2R5LFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaCA9IGdldE9yaWdpbmFsRmV0Y2gyKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHJlbW92ZVVuZGVmaW5lZEVudHJpZXMoaGVhZGVycyksXG4gICAgICBib2R5OiBib2R5LmNvbnRlbnQsXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBlcnJvciByZXNwb25zZVwiLFxuICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvckluZm9ybWF0aW9uLnZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUZldGNoRXJyb3IoeyBlcnJvciwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXMgfSk7XG4gIH1cbn07XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWRFcnJvciA9IGF3YWl0IHBhcnNlSlNPTih7XG4gICAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgICBzY2hlbWE6IGVycm9yU2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3JUb01lc3NhZ2UocGFyc2VkRXJyb3IpLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBkYXRhOiBwYXJzZWRFcnJvcixcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSwgcGFyc2VkRXJyb3IpXG4gICAgICB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICBzY2hlbWE6IGNodW5rU2NoZW1hXG4gICAgfSlcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gcmVzcG9uc2VcIixcbiAgICAgIGNhdXNlOiBwYXJzZWRSZXN1bHQuZXJyb3IsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHksXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBwYXJzZWRSZXN1bHQudmFsdWUsXG4gICAgcmF3VmFsdWU6IHBhcnNlZFJlc3VsdC5yYXdWYWx1ZVxuICB9O1xufTtcbnZhciBzY2hlbWFTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnNjaGVtYVwiKTtcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGFycmF5KSB7XG4gIGxldCBsYXRpbjFzdHJpbmcgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGF0aW4xc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShsYXRpbjFzdHJpbmcpO1xufVxuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2godXJsKSB7XG4gIHJldHVybiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlYXNvbmluZy1kZXRhaWxzLnRzXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZC92NFwiO1xudmFyIFJlYXNvbmluZ0RldGFpbFN1bW1hcnlTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbChcInJlYXNvbmluZy5zdW1tYXJ5XCIgLyogU3VtbWFyeSAqLyksXG4gIHN1bW1hcnk6IHouc3RyaW5nKClcbn0pO1xudmFyIFJlYXNvbmluZ0RldGFpbEVuY3J5cHRlZFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgdHlwZTogei5saXRlcmFsKFwicmVhc29uaW5nLmVuY3J5cHRlZFwiIC8qIEVuY3J5cHRlZCAqLyksXG4gIGRhdGE6IHouc3RyaW5nKClcbn0pO1xudmFyIFJlYXNvbmluZ0RldGFpbFRleHRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbChcInJlYXNvbmluZy50ZXh0XCIgLyogVGV4dCAqLyksXG4gIHRleHQ6IHouc3RyaW5nKCkubnVsbGlzaCgpLFxuICBzaWduYXR1cmU6IHouc3RyaW5nKCkubnVsbGlzaCgpXG59KTtcbnZhciBSZWFzb25pbmdEZXRhaWxVbmlvblNjaGVtYSA9IHoudW5pb24oW1xuICBSZWFzb25pbmdEZXRhaWxTdW1tYXJ5U2NoZW1hLFxuICBSZWFzb25pbmdEZXRhaWxFbmNyeXB0ZWRTY2hlbWEsXG4gIFJlYXNvbmluZ0RldGFpbFRleHRTY2hlbWFcbl0pO1xudmFyIFJlYXNvbmluZ0RldGFpbHNXaXRoVW5rbm93blNjaGVtYSA9IHoudW5pb24oW1xuICBSZWFzb25pbmdEZXRhaWxVbmlvblNjaGVtYSxcbiAgei51bmtub3duKCkudHJhbnNmb3JtKCgpID0+IG51bGwpXG5dKTtcbnZhciBSZWFzb25pbmdEZXRhaWxBcnJheVNjaGVtYSA9IHouYXJyYXkoUmVhc29uaW5nRGV0YWlsc1dpdGhVbmtub3duU2NoZW1hKS50cmFuc2Zvcm0oKGQpID0+IGQuZmlsdGVyKChkMikgPT4gISFkMikpO1xuXG4vLyBzcmMvc2NoZW1hcy9lcnJvci1yZXNwb25zZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBPcGVuUm91dGVyRXJyb3JSZXNwb25zZVNjaGVtYSA9IHoyLm9iamVjdCh7XG4gIGVycm9yOiB6Mi5vYmplY3Qoe1xuICAgIGNvZGU6IHoyLnVuaW9uKFt6Mi5zdHJpbmcoKSwgejIubnVtYmVyKCldKS5udWxsYWJsZSgpLm9wdGlvbmFsKCkuZGVmYXVsdChudWxsKSxcbiAgICBtZXNzYWdlOiB6Mi5zdHJpbmcoKSxcbiAgICB0eXBlOiB6Mi5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKCkuZGVmYXVsdChudWxsKSxcbiAgICBwYXJhbTogejIuYW55KCkubnVsbGFibGUoKS5vcHRpb25hbCgpLmRlZmF1bHQobnVsbClcbiAgfSlcbn0pO1xudmFyIG9wZW5yb3V0ZXJGYWlsZWRSZXNwb25zZUhhbmRsZXIgPSBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIoe1xuICBlcnJvclNjaGVtYTogT3BlblJvdXRlckVycm9yUmVzcG9uc2VTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlOiAoZGF0YSkgPT4gZGF0YS5lcnJvci5tZXNzYWdlXG59KTtcblxuLy8gc3JjL3V0aWxzL21hcC1maW5pc2gtcmVhc29uLnRzXG5mdW5jdGlvbiBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGZpbmlzaFJlYXNvbikge1xuICBzd2l0Y2ggKGZpbmlzaFJlYXNvbikge1xuICAgIGNhc2UgXCJzdG9wXCI6XG4gICAgICByZXR1cm4gXCJzdG9wXCI7XG4gICAgY2FzZSBcImxlbmd0aFwiOlxuICAgICAgcmV0dXJuIFwibGVuZ3RoXCI7XG4gICAgY2FzZSBcImNvbnRlbnRfZmlsdGVyXCI6XG4gICAgICByZXR1cm4gXCJjb250ZW50LWZpbHRlclwiO1xuICAgIGNhc2UgXCJmdW5jdGlvbl9jYWxsXCI6XG4gICAgY2FzZSBcInRvb2xfY2FsbHNcIjpcbiAgICAgIHJldHVybiBcInRvb2wtY2FsbHNcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICB9XG59XG5cbi8vIHNyYy9jaGF0L2lzLXVybC50c1xuZnVuY3Rpb24gaXNVcmwoe1xuICB1cmwsXG4gIHByb3RvY29sc1xufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICByZXR1cm4gcHJvdG9jb2xzLmhhcyh1cmxPYmoucHJvdG9jb2wpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIHNyYy9jaGF0L2ZpbGUtdXJsLXV0aWxzLnRzXG5mdW5jdGlvbiBnZXRGaWxlVXJsKHtcbiAgcGFydCxcbiAgZGVmYXVsdE1lZGlhVHlwZVxufSkge1xuICB2YXIgX2ExNSwgX2I7XG4gIGlmIChwYXJ0LmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgYmFzZTY0ID0gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChwYXJ0LmRhdGEpO1xuICAgIHJldHVybiBgZGF0YTokeyhfYTE1ID0gcGFydC5tZWRpYVR5cGUpICE9IG51bGwgPyBfYTE1IDogZGVmYXVsdE1lZGlhVHlwZX07YmFzZTY0LCR7YmFzZTY0fWA7XG4gIH1cbiAgY29uc3Qgc3RyaW5nVXJsID0gcGFydC5kYXRhLnRvU3RyaW5nKCk7XG4gIGlmIChpc1VybCh7XG4gICAgdXJsOiBzdHJpbmdVcmwsXG4gICAgcHJvdG9jb2xzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwOlwiLCBcImh0dHBzOlwiXSlcbiAgfSkpIHtcbiAgICByZXR1cm4gc3RyaW5nVXJsO1xuICB9XG4gIHJldHVybiBzdHJpbmdVcmwuc3RhcnRzV2l0aChcImRhdGE6XCIpID8gc3RyaW5nVXJsIDogYGRhdGE6JHsoX2IgPSBwYXJ0Lm1lZGlhVHlwZSkgIT0gbnVsbCA/IF9iIDogZGVmYXVsdE1lZGlhVHlwZX07YmFzZTY0LCR7c3RyaW5nVXJsfWA7XG59XG5cbi8vIHNyYy9jaGF0L2NvbnZlcnQtdG8tb3BlbnJvdXRlci1jaGF0LW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBnZXRDYWNoZUNvbnRyb2wocHJvdmlkZXJNZXRhZGF0YSkge1xuICB2YXIgX2ExNSwgX2IsIF9jO1xuICBjb25zdCBhbnRocm9waWMgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLmFudGhyb3BpYztcbiAgY29uc3Qgb3BlbnJvdXRlcjIgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLm9wZW5yb3V0ZXI7XG4gIHJldHVybiAoX2MgPSAoX2IgPSAoX2ExNSA9IG9wZW5yb3V0ZXIyID09IG51bGwgPyB2b2lkIDAgOiBvcGVucm91dGVyMi5jYWNoZUNvbnRyb2wpICE9IG51bGwgPyBfYTE1IDogb3BlbnJvdXRlcjIgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZW5yb3V0ZXIyLmNhY2hlX2NvbnRyb2wpICE9IG51bGwgPyBfYiA6IGFudGhyb3BpYyA9PSBudWxsID8gdm9pZCAwIDogYW50aHJvcGljLmNhY2hlQ29udHJvbCkgIT0gbnVsbCA/IF9jIDogYW50aHJvcGljID09IG51bGwgPyB2b2lkIDAgOiBhbnRocm9waWMuY2FjaGVfY29udHJvbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5Sb3V0ZXJDaGF0TWVzc2FnZXMocHJvbXB0KSB7XG4gIHZhciBfYTE1LCBfYiwgX2M7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIGZvciAoY29uc3QgeyByb2xlLCBjb250ZW50LCBwcm92aWRlck9wdGlvbnMgfSBvZiBwcm9tcHQpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgY2FjaGVfY29udHJvbDogZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDEgJiYgKChfYTE1ID0gY29udGVudFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTUudHlwZSkgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gKF9iID0gZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucykpICE9IG51bGwgPyBfYiA6IGdldENhY2hlQ29udHJvbChjb250ZW50WzBdLnByb3ZpZGVyT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgY29udGVudFdpdGhDYWNoZUNvbnRyb2wgPSBjYWNoZUNvbnRyb2wgPyBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50WzBdLnRleHQsXG4gICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0gOiBjb250ZW50WzBdLnRleHQ7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRXaXRoQ2FjaGVDb250cm9sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZUNhY2hlQ29udHJvbCA9IGdldENhY2hlQ29udHJvbChwcm92aWRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb250ZW50UGFydHMgPSBjb250ZW50Lm1hcChcbiAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMTYsIF9iMiwgX2MyLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gKF9hMTYgPSBnZXRDYWNoZUNvbnRyb2wocGFydC5wcm92aWRlck9wdGlvbnMpKSAhPSBudWxsID8gX2ExNiA6IG1lc3NhZ2VDYWNoZUNvbnRyb2w7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIEZvciB0ZXh0IHBhcnRzLCBvbmx5IHVzZSBwYXJ0LXNwZWNpZmljIGNhY2hlIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iMiA9IHBhcnQubWVkaWFUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldEZpbGVVcmwoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGltYWdlIHBhcnRzLCB1c2UgcGFydC1zcGVjaWZpYyBvciBtZXNzYWdlLWxldmVsIGNhY2hlIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVfY29udHJvbDogY2FjaGVDb250cm9sXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IFN0cmluZyhcbiAgICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IChfZCA9IChfYzIgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5vcGVucm91dGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZmlsZW5hbWUpICE9IG51bGwgPyBfZSA6IHBhcnQuZmlsZW5hbWUpICE9IG51bGwgPyBfZiA6IFwiXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVEYXRhID0gZ2V0RmlsZVVybCh7XG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdE1lZGlhVHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1VybCh7XG4gICAgICAgICAgICAgICAgICB1cmw6IGZpbGVEYXRhLFxuICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwOlwiLCBcImh0dHBzOlwiXSlcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBmaWxlRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBmaWxlRGF0YVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBjYWNoZV9jb250cm9sOiBjYWNoZUNvbnRyb2xcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50UGFydHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHJlYXNvbmluZyA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYXNvbmluZ0RldGFpbHMgPSBbXTtcbiAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocGFydC5pbnB1dClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZWFzb25pbmcgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogdGV4dCxcbiAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxscyA6IHZvaWQgMCxcbiAgICAgICAgICByZWFzb25pbmc6IHJlYXNvbmluZyB8fCB2b2lkIDAsXG4gICAgICAgICAgcmVhc29uaW5nX2RldGFpbHM6IHJlYXNvbmluZ0RldGFpbHMubGVuZ3RoID4gMCA/IHJlYXNvbmluZ0RldGFpbHMgOiB2b2lkIDAsXG4gICAgICAgICAgY2FjaGVfY29udHJvbDogZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xSZXNwb25zZSBvZiBjb250ZW50KSB7XG4gICAgICAgICAgY29uc3QgY29udGVudDIgPSBnZXRUb29sUmVzdWx0Q29udGVudCh0b29sUmVzcG9uc2UpO1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRvb2xSZXNwb25zZS50b29sQ2FsbElkLFxuICAgICAgICAgICAgY29udGVudDogY29udGVudDIsXG4gICAgICAgICAgICBjYWNoZV9jb250cm9sOiAoX2MgPSBnZXRDYWNoZUNvbnRyb2wocHJvdmlkZXJPcHRpb25zKSkgIT0gbnVsbCA/IF9jIDogZ2V0Q2FjaGVDb250cm9sKHRvb2xSZXNwb25zZS5wcm92aWRlck9wdGlvbnMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVzc2FnZXM7XG59XG5mdW5jdGlvbiBnZXRUb29sUmVzdWx0Q29udGVudChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQub3V0cHV0LnR5cGUgPT09IFwidGV4dFwiID8gaW5wdXQub3V0cHV0LnZhbHVlIDogSlNPTi5zdHJpbmdpZnkoaW5wdXQub3V0cHV0LnZhbHVlKTtcbn1cblxuLy8gc3JjL2NoYXQvZ2V0LXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZC92NFwiO1xudmFyIENoYXRDb21wbGV0aW9uVG9vbENob2ljZVNjaGVtYSA9IHozLnVuaW9uKFtcbiAgejMubGl0ZXJhbChcImF1dG9cIiksXG4gIHozLmxpdGVyYWwoXCJub25lXCIpLFxuICB6My5saXRlcmFsKFwicmVxdWlyZWRcIiksXG4gIHozLm9iamVjdCh7XG4gICAgdHlwZTogejMubGl0ZXJhbChcImZ1bmN0aW9uXCIpLFxuICAgIGZ1bmN0aW9uOiB6My5vYmplY3Qoe1xuICAgICAgbmFtZTogejMuc3RyaW5nKClcbiAgICB9KVxuICB9KVxuXSk7XG5mdW5jdGlvbiBnZXRDaGF0Q29tcGxldGlvblRvb2xDaG9pY2UodG9vbENob2ljZSkge1xuICBzd2l0Y2ggKHRvb2xDaG9pY2UudHlwZSkge1xuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB0b29sQ2hvaWNlLnR5cGU7XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRvb2xDaG9pY2U7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjaG9pY2UgdHlwZTogJHt0b29sQ2hvaWNlfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9zY2hlbWFzLnRzXG5pbXBvcnQgeyB6IGFzIHo1IH0gZnJvbSBcInpvZC92NFwiO1xudmFyIE9wZW5Sb3V0ZXJDaGF0Q29tcGxldGlvbkJhc2VSZXNwb25zZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIGlkOiB6NS5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBtb2RlbDogejUuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXI6IHo1LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHVzYWdlOiB6NS5vYmplY3Qoe1xuICAgIHByb21wdF90b2tlbnM6IHo1Lm51bWJlcigpLFxuICAgIHByb21wdF90b2tlbnNfZGV0YWlsczogejUub2JqZWN0KHtcbiAgICAgIGNhY2hlZF90b2tlbnM6IHo1Lm51bWJlcigpXG4gICAgfSkubnVsbGlzaCgpLFxuICAgIGNvbXBsZXRpb25fdG9rZW5zOiB6NS5udW1iZXIoKSxcbiAgICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzOiB6NS5vYmplY3Qoe1xuICAgICAgcmVhc29uaW5nX3Rva2VuczogejUubnVtYmVyKClcbiAgICB9KS5udWxsaXNoKCksXG4gICAgdG90YWxfdG9rZW5zOiB6NS5udW1iZXIoKSxcbiAgICBjb3N0OiB6NS5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIGNvc3RfZGV0YWlsczogejUub2JqZWN0KHtcbiAgICAgIHVwc3RyZWFtX2luZmVyZW5jZV9jb3N0OiB6NS5udW1iZXIoKS5udWxsaXNoKClcbiAgICB9KS5udWxsaXNoKClcbiAgfSkubnVsbGlzaCgpXG59KTtcbnZhciBPcGVuUm91dGVyTm9uU3RyZWFtQ2hhdENvbXBsZXRpb25SZXNwb25zZVNjaGVtYSA9IE9wZW5Sb3V0ZXJDaGF0Q29tcGxldGlvbkJhc2VSZXNwb25zZVNjaGVtYS5leHRlbmQoe1xuICBjaG9pY2VzOiB6NS5hcnJheShcbiAgICB6NS5vYmplY3Qoe1xuICAgICAgbWVzc2FnZTogejUub2JqZWN0KHtcbiAgICAgICAgcm9sZTogejUubGl0ZXJhbChcImFzc2lzdGFudFwiKSxcbiAgICAgICAgY29udGVudDogejUuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICAgICAgICByZWFzb25pbmc6IHo1LnN0cmluZygpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcmVhc29uaW5nX2RldGFpbHM6IFJlYXNvbmluZ0RldGFpbEFycmF5U2NoZW1hLm51bGxpc2goKSxcbiAgICAgICAgdG9vbF9jYWxsczogejUuYXJyYXkoXG4gICAgICAgICAgejUub2JqZWN0KHtcbiAgICAgICAgICAgIGlkOiB6NS5zdHJpbmcoKS5vcHRpb25hbCgpLm51bGxhYmxlKCksXG4gICAgICAgICAgICB0eXBlOiB6NS5saXRlcmFsKFwiZnVuY3Rpb25cIiksXG4gICAgICAgICAgICBmdW5jdGlvbjogejUub2JqZWN0KHtcbiAgICAgICAgICAgICAgbmFtZTogejUuc3RyaW5nKCksXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogejUuc3RyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKS5vcHRpb25hbCgpLFxuICAgICAgICBhbm5vdGF0aW9uczogejUuYXJyYXkoXG4gICAgICAgICAgejUub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo1LmVudW0oW1widXJsX2NpdGF0aW9uXCJdKSxcbiAgICAgICAgICAgIHVybF9jaXRhdGlvbjogejUub2JqZWN0KHtcbiAgICAgICAgICAgICAgZW5kX2luZGV4OiB6NS5udW1iZXIoKSxcbiAgICAgICAgICAgICAgc3RhcnRfaW5kZXg6IHo1Lm51bWJlcigpLFxuICAgICAgICAgICAgICB0aXRsZTogejUuc3RyaW5nKCksXG4gICAgICAgICAgICAgIHVybDogejUuc3RyaW5nKCksXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IHo1LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKS5udWxsaXNoKClcbiAgICAgIH0pLFxuICAgICAgaW5kZXg6IHo1Lm51bWJlcigpLm51bGxpc2goKSxcbiAgICAgIGxvZ3Byb2JzOiB6NS5vYmplY3Qoe1xuICAgICAgICBjb250ZW50OiB6NS5hcnJheShcbiAgICAgICAgICB6NS5vYmplY3Qoe1xuICAgICAgICAgICAgdG9rZW46IHo1LnN0cmluZygpLFxuICAgICAgICAgICAgbG9ncHJvYjogejUubnVtYmVyKCksXG4gICAgICAgICAgICB0b3BfbG9ncHJvYnM6IHo1LmFycmF5KFxuICAgICAgICAgICAgICB6NS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIHRva2VuOiB6NS5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsb2dwcm9iOiB6NS5udW1iZXIoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pXG4gICAgICAgICkubnVsbGFibGUoKVxuICAgICAgfSkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICAgICAgZmluaXNoX3JlYXNvbjogejUuc3RyaW5nKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpXG4gICAgfSlcbiAgKVxufSk7XG52YXIgT3BlblJvdXRlclN0cmVhbUNoYXRDb21wbGV0aW9uQ2h1bmtTY2hlbWEgPSB6NS51bmlvbihbXG4gIE9wZW5Sb3V0ZXJDaGF0Q29tcGxldGlvbkJhc2VSZXNwb25zZVNjaGVtYS5leHRlbmQoe1xuICAgIGNob2ljZXM6IHo1LmFycmF5KFxuICAgICAgejUub2JqZWN0KHtcbiAgICAgICAgZGVsdGE6IHo1Lm9iamVjdCh7XG4gICAgICAgICAgcm9sZTogejUuZW51bShbXCJhc3Npc3RhbnRcIl0pLm9wdGlvbmFsKCksXG4gICAgICAgICAgY29udGVudDogejUuc3RyaW5nKCkubnVsbGlzaCgpLFxuICAgICAgICAgIHJlYXNvbmluZzogejUuc3RyaW5nKCkubnVsbGlzaCgpLm9wdGlvbmFsKCksXG4gICAgICAgICAgcmVhc29uaW5nX2RldGFpbHM6IFJlYXNvbmluZ0RldGFpbEFycmF5U2NoZW1hLm51bGxpc2goKSxcbiAgICAgICAgICB0b29sX2NhbGxzOiB6NS5hcnJheShcbiAgICAgICAgICAgIHo1Lm9iamVjdCh7XG4gICAgICAgICAgICAgIGluZGV4OiB6NS5udW1iZXIoKS5udWxsaXNoKCksXG4gICAgICAgICAgICAgIGlkOiB6NS5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgICAgIHR5cGU6IHo1LmxpdGVyYWwoXCJmdW5jdGlvblwiKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogejUub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiB6NS5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiB6NS5zdHJpbmcoKS5udWxsaXNoKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5udWxsaXNoKCksXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IHo1LmFycmF5KFxuICAgICAgICAgICAgejUub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejUuZW51bShbXCJ1cmxfY2l0YXRpb25cIl0pLFxuICAgICAgICAgICAgICB1cmxfY2l0YXRpb246IHo1Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgZW5kX2luZGV4OiB6NS5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICBzdGFydF9pbmRleDogejUubnVtYmVyKCksXG4gICAgICAgICAgICAgICAgdGl0bGU6IHo1LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIHVybDogejUuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgY29udGVudDogejUuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLm51bGxpc2goKVxuICAgICAgICB9KS5udWxsaXNoKCksXG4gICAgICAgIGxvZ3Byb2JzOiB6NS5vYmplY3Qoe1xuICAgICAgICAgIGNvbnRlbnQ6IHo1LmFycmF5KFxuICAgICAgICAgICAgejUub2JqZWN0KHtcbiAgICAgICAgICAgICAgdG9rZW46IHo1LnN0cmluZygpLFxuICAgICAgICAgICAgICBsb2dwcm9iOiB6NS5udW1iZXIoKSxcbiAgICAgICAgICAgICAgdG9wX2xvZ3Byb2JzOiB6NS5hcnJheShcbiAgICAgICAgICAgICAgICB6NS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgdG9rZW46IHo1LnN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgbG9ncHJvYjogejUubnVtYmVyKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkubnVsbGFibGUoKVxuICAgICAgICB9KS5udWxsaXNoKCksXG4gICAgICAgIGZpbmlzaF9yZWFzb246IHo1LnN0cmluZygpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgICAgICAgaW5kZXg6IHo1Lm51bWJlcigpLm51bGxpc2goKVxuICAgICAgfSlcbiAgICApXG4gIH0pLFxuICBPcGVuUm91dGVyRXJyb3JSZXNwb25zZVNjaGVtYVxuXSk7XG5cbi8vIHNyYy9jaGF0L2luZGV4LnRzXG52YXIgT3BlblJvdXRlckNoYXRMYW5ndWFnZU1vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBzZXR0aW5ncywgY29uZmlnKSB7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjJcIjtcbiAgICB0aGlzLnByb3ZpZGVyID0gXCJvcGVucm91dGVyXCI7XG4gICAgdGhpcy5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGUgPSBcInRvb2xcIjtcbiAgICB0aGlzLnN1cHBvcnRlZFVybHMgPSB7XG4gICAgICBcImltYWdlLypcIjogW1xuICAgICAgICAvXmRhdGE6aW1hZ2VcXC9bYS16QS1aXSs7YmFzZTY0LC8sXG4gICAgICAgIC9eaHR0cHM/OlxcL1xcLy4rXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8d2VicCkkL2lcbiAgICAgIF0sXG4gICAgICAvLyAndGV4dC8qJzogWy9eZGF0YTp0ZXh0XFwvLywgL15odHRwcz86XFwvXFwvLiskL10sXG4gICAgICBcImFwcGxpY2F0aW9uLypcIjogWy9eZGF0YTphcHBsaWNhdGlvblxcLy8sIC9eaHR0cHM/OlxcL1xcLy4rJC9dXG4gICAgfTtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBnZXRBcmdzKHtcbiAgICBwcm9tcHQsXG4gICAgbWF4T3V0cHV0VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgc2VlZCxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHJlc3BvbnNlRm9ybWF0LFxuICAgIHRvcEssXG4gICAgdG9vbHMsXG4gICAgdG9vbENob2ljZVxuICB9KSB7XG4gICAgdmFyIF9hMTU7XG4gICAgY29uc3QgYmFzZUFyZ3MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAvLyBtb2RlbCBpZDpcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbHM6IHRoaXMuc2V0dGluZ3MubW9kZWxzLFxuICAgICAgLy8gbW9kZWwgc3BlY2lmaWMgc2V0dGluZ3M6XG4gICAgICBsb2dpdF9iaWFzOiB0aGlzLnNldHRpbmdzLmxvZ2l0QmlhcyxcbiAgICAgIGxvZ3Byb2JzOiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSB0cnVlIHx8IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcIm51bWJlclwiID8gdHJ1ZSA6IHZvaWQgMCxcbiAgICAgIHRvcF9sb2dwcm9iczogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwibnVtYmVyXCIgPyB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzIDogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwiYm9vbGVhblwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA/IDAgOiB2b2lkIDAgOiB2b2lkIDAsXG4gICAgICB1c2VyOiB0aGlzLnNldHRpbmdzLnVzZXIsXG4gICAgICBwYXJhbGxlbF90b29sX2NhbGxzOiB0aGlzLnNldHRpbmdzLnBhcmFsbGVsVG9vbENhbGxzLFxuICAgICAgLy8gc3RhbmRhcmRpemVkIHNldHRpbmdzOlxuICAgICAgbWF4X3Rva2VuczogbWF4T3V0cHV0VG9rZW5zLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICB0b3BfcDogdG9wUCxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgc2VlZCxcbiAgICAgIHN0b3A6IHN0b3BTZXF1ZW5jZXMsXG4gICAgICByZXNwb25zZV9mb3JtYXQ6IHJlc3BvbnNlRm9ybWF0LFxuICAgICAgdG9wX2s6IHRvcEssXG4gICAgICAvLyBtZXNzYWdlczpcbiAgICAgIG1lc3NhZ2VzOiBjb252ZXJ0VG9PcGVuUm91dGVyQ2hhdE1lc3NhZ2VzKHByb21wdCksXG4gICAgICAvLyBPcGVuUm91dGVyIHNwZWNpZmljIHNldHRpbmdzOlxuICAgICAgaW5jbHVkZV9yZWFzb25pbmc6IHRoaXMuc2V0dGluZ3MuaW5jbHVkZVJlYXNvbmluZyxcbiAgICAgIHJlYXNvbmluZzogdGhpcy5zZXR0aW5ncy5yZWFzb25pbmcsXG4gICAgICB1c2FnZTogdGhpcy5zZXR0aW5ncy51c2FnZSxcbiAgICAgIC8vIFdlYiBzZWFyY2ggc2V0dGluZ3M6XG4gICAgICBwbHVnaW5zOiB0aGlzLnNldHRpbmdzLnBsdWdpbnMsXG4gICAgICB3ZWJfc2VhcmNoX29wdGlvbnM6IHRoaXMuc2V0dGluZ3Mud2ViX3NlYXJjaF9vcHRpb25zLFxuICAgICAgLy8gUHJvdmlkZXIgcm91dGluZyBzZXR0aW5nczpcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnNldHRpbmdzLnByb3ZpZGVyXG4gICAgfSwgdGhpcy5jb25maWcuZXh0cmFCb2R5KSwgdGhpcy5zZXR0aW5ncy5leHRyYUJvZHkpO1xuICAgIGlmICgocmVzcG9uc2VGb3JtYXQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlRm9ybWF0LnR5cGUpID09PSBcImpzb25cIiAmJiByZXNwb25zZUZvcm1hdC5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGJhc2VBcmdzKSwge1xuICAgICAgICByZXNwb25zZV9mb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiBcImpzb25fc2NoZW1hXCIsXG4gICAgICAgICAganNvbl9zY2hlbWE6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgIHNjaGVtYTogcmVzcG9uc2VGb3JtYXQuc2NoZW1hLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgbmFtZTogKF9hMTUgPSByZXNwb25zZUZvcm1hdC5uYW1lKSAhPSBudWxsID8gX2ExNSA6IFwicmVzcG9uc2VcIlxuICAgICAgICAgIH0sIHJlc3BvbnNlRm9ybWF0LmRlc2NyaXB0aW9uICYmIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByZXNwb25zZUZvcm1hdC5kZXNjcmlwdGlvblxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodG9vbHMgJiYgdG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbWFwcGVkVG9vbHMgPSB0b29scy5maWx0ZXIoKHRvb2wpID0+IHRvb2wudHlwZSA9PT0gXCJmdW5jdGlvblwiKS5tYXAoKHRvb2wpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICBuYW1lOiB0b29sLm5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICAgICAgcGFyYW1ldGVyczogdG9vbC5pbnB1dFNjaGVtYVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUFyZ3MpLCB7XG4gICAgICAgIHRvb2xzOiBtYXBwZWRUb29scyxcbiAgICAgICAgdG9vbF9jaG9pY2U6IHRvb2xDaG9pY2UgPyBnZXRDaGF0Q29tcGxldGlvblRvb2xDaG9pY2UodG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUFyZ3M7XG4gIH1cbiAgYXN5bmMgZG9HZW5lcmF0ZShvcHRpb25zKSB7XG4gICAgdmFyIF9hMTUsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeDtcbiAgICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSBvcHRpb25zLnByb3ZpZGVyT3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBvcGVucm91dGVyT3B0aW9ucyA9IHByb3ZpZGVyT3B0aW9ucy5vcGVucm91dGVyIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5nZXRBcmdzKG9wdGlvbnMpKSwgb3BlbnJvdXRlck9wdGlvbnMpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHJlc3BvbnNlLCByZXNwb25zZUhlYWRlcnMgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jaGF0L2NvbXBsZXRpb25zXCIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVycyh0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5OiBhcmdzLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVucm91dGVyRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcihcbiAgICAgICAgT3BlblJvdXRlck5vblN0cmVhbUNoYXRDb21wbGV0aW9uUmVzcG9uc2VTY2hlbWFcbiAgICAgICksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIGNvbnN0IGNob2ljZSA9IHJlc3BvbnNlLmNob2ljZXNbMF07XG4gICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNob2ljZSBpbiByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgY29uc3QgdXNhZ2VJbmZvID0gcmVzcG9uc2UudXNhZ2UgPyB7XG4gICAgICBpbnB1dFRva2VuczogKF9hMTUgPSByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zKSAhPSBudWxsID8gX2ExNSA6IDAsXG4gICAgICBvdXRwdXRUb2tlbnM6IChfYiA9IHJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zKSAhPSBudWxsID8gX2IgOiAwLFxuICAgICAgdG90YWxUb2tlbnM6ICgoX2MgPSByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zKSAhPSBudWxsID8gX2MgOiAwKSArICgoX2QgPSByZXNwb25zZS51c2FnZS5jb21wbGV0aW9uX3Rva2VucykgIT0gbnVsbCA/IF9kIDogMCksXG4gICAgICByZWFzb25pbmdUb2tlbnM6IChfZiA9IChfZSA9IHJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5yZWFzb25pbmdfdG9rZW5zKSAhPSBudWxsID8gX2YgOiAwLFxuICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IChfaCA9IChfZyA9IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmNhY2hlZF90b2tlbnMpICE9IG51bGwgPyBfaCA6IDBcbiAgICB9IDoge1xuICAgICAgaW5wdXRUb2tlbnM6IDAsXG4gICAgICBvdXRwdXRUb2tlbnM6IDAsXG4gICAgICB0b3RhbFRva2VuczogMCxcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogMCxcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiAwXG4gICAgfTtcbiAgICBjb25zdCByZWFzb25pbmdEZXRhaWxzID0gKF9pID0gY2hvaWNlLm1lc3NhZ2UucmVhc29uaW5nX2RldGFpbHMpICE9IG51bGwgPyBfaSA6IFtdO1xuICAgIGNvbnN0IHJlYXNvbmluZyA9IHJlYXNvbmluZ0RldGFpbHMubGVuZ3RoID4gMCA/IHJlYXNvbmluZ0RldGFpbHMubWFwKChkZXRhaWwpID0+IHtcbiAgICAgIHN3aXRjaCAoZGV0YWlsLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy50ZXh0XCIgLyogVGV4dCAqLzoge1xuICAgICAgICAgIGlmIChkZXRhaWwudGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgdGV4dDogZGV0YWlsLnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmcuc3VtbWFyeVwiIC8qIFN1bW1hcnkgKi86IHtcbiAgICAgICAgICBpZiAoZGV0YWlsLnN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgIHRleHQ6IGRldGFpbC5zdW1tYXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLmVuY3J5cHRlZFwiIC8qIEVuY3J5cHRlZCAqLzoge1xuICAgICAgICAgIGlmIChkZXRhaWwuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgdGV4dDogXCJbUkVEQUNURURdXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBkZXRhaWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcigocCkgPT4gcCAhPT0gbnVsbCkgOiBjaG9pY2UubWVzc2FnZS5yZWFzb25pbmcgPyBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgIHRleHQ6IGNob2ljZS5tZXNzYWdlLnJlYXNvbmluZ1xuICAgICAgfVxuICAgIF0gOiBbXTtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgY29udGVudC5wdXNoKC4uLnJlYXNvbmluZyk7XG4gICAgaWYgKGNob2ljZS5tZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBjaG9pY2UubWVzc2FnZS5jb250ZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogKF9qID0gdG9vbENhbGwuaWQpICE9IG51bGwgPyBfaiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICBpbnB1dDogdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UuYW5ub3RhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBjaG9pY2UubWVzc2FnZS5hbm5vdGF0aW9ucykge1xuICAgICAgICBpZiAoYW5ub3RhdGlvbi50eXBlID09PSBcInVybF9jaXRhdGlvblwiKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VUeXBlOiBcInVybFwiLFxuICAgICAgICAgICAgaWQ6IGFubm90YXRpb24udXJsX2NpdGF0aW9uLnVybCxcbiAgICAgICAgICAgIHVybDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udXJsLFxuICAgICAgICAgICAgdGl0bGU6IGFubm90YXRpb24udXJsX2NpdGF0aW9uLnRpdGxlLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24uY29udGVudCB8fCBcIlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudCxcbiAgICAgIGZpbmlzaFJlYXNvbjogbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbiksXG4gICAgICB1c2FnZTogdXNhZ2VJbmZvLFxuICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgcHJvdmlkZXI6IChfayA9IHJlc3BvbnNlLnByb3ZpZGVyKSAhPSBudWxsID8gX2sgOiBcIlwiLFxuICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IChfbCA9IHVzYWdlSW5mby5pbnB1dFRva2VucykgIT0gbnVsbCA/IF9sIDogMCxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IChfbSA9IHVzYWdlSW5mby5vdXRwdXRUb2tlbnMpICE9IG51bGwgPyBfbSA6IDAsXG4gICAgICAgICAgICB0b3RhbFRva2VuczogKF9uID0gdXNhZ2VJbmZvLnRvdGFsVG9rZW5zKSAhPSBudWxsID8gX24gOiAwLFxuICAgICAgICAgICAgY29zdDogKF9vID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfby5jb3N0LFxuICAgICAgICAgICAgcHJvbXB0VG9rZW5zRGV0YWlsczoge1xuICAgICAgICAgICAgICBjYWNoZWRUb2tlbnM6IChfciA9IChfcSA9IChfcCA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX3AucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3EuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9yIDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1Rva2VuczogKF91ID0gKF90ID0gKF9zID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfcy5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3QucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF91IDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvc3REZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHVwc3RyZWFtSW5mZXJlbmNlQ29zdDogKF94ID0gKF93ID0gKF92ID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdi5jb3N0X2RldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfdy51cHN0cmVhbV9pbmZlcmVuY2VfY29zdCkgIT0gbnVsbCA/IF94IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keTogYXJncyB9LFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmlkLFxuICAgICAgICBtb2RlbElkOiByZXNwb25zZS5tb2RlbCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBkb1N0cmVhbShvcHRpb25zKSB7XG4gICAgdmFyIF9hMTU7XG4gICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gb3B0aW9ucy5wcm92aWRlck9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgb3BlbnJvdXRlck9wdGlvbnMgPSBwcm92aWRlck9wdGlvbnMub3BlbnJvdXRlciB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0QXJncyhvcHRpb25zKSksIG9wZW5yb3V0ZXJPcHRpb25zKTtcbiAgICBjb25zdCB7IHZhbHVlOiByZXNwb25zZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXJncyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgc3RyZWFtX29wdGlvbnMgd2hlbiBpbiBzdHJpY3QgY29tcGF0aWJpbGl0eSBtb2RlOlxuICAgICAgICBzdHJlYW1fb3B0aW9uczogdGhpcy5jb25maWcuY29tcGF0aWJpbGl0eSA9PT0gXCJzdHJpY3RcIiA/IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBpbmNsdWRlX3VzYWdlOiB0cnVlXG4gICAgICAgIH0sICgoX2ExNSA9IHRoaXMuc2V0dGluZ3MudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE1LmluY2x1ZGUpID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB7fSkgOiB2b2lkIDBcbiAgICAgIH0pLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVucm91dGVyRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgIE9wZW5Sb3V0ZXJTdHJlYW1DaGF0Q29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgaW5wdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBvdXRwdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICB0b3RhbFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBjb25zdCBvcGVucm91dGVyVXNhZ2UgPSB7fTtcbiAgICBsZXQgdGV4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVhc29uaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCB0ZXh0SWQ7XG4gICAgbGV0IHJlYXNvbmluZ0lkO1xuICAgIGxldCBvcGVucm91dGVyUmVzcG9uc2VJZDtcbiAgICBsZXQgcHJvdmlkZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIF9hMTYsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uO1xuICAgICAgICAgICAgaWYgKCFjaHVuay5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogY2h1bmsuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2h1bmsudmFsdWU7XG4gICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogdmFsdWUuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgICBwcm92aWRlciA9IHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJSZXNwb25zZUlkID0gdmFsdWUuaWQ7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZXNwb25zZS1tZXRhZGF0YVwiLFxuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5tb2RlbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICBtb2RlbElkOiB2YWx1ZS5tb2RlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHVzYWdlLmlucHV0VG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgICAgdXNhZ2Uub3V0cHV0VG9rZW5zID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIHVzYWdlLnRvdGFsVG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucyArIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UucHJvbXB0VG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZElucHV0VG9rZW5zID0gKF9hMTYgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zX2RldGFpbHMuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9hMTYgOiAwO1xuICAgICAgICAgICAgICAgIHVzYWdlLmNhY2hlZElucHV0VG9rZW5zID0gY2FjaGVkSW5wdXRUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLnByb21wdFRva2Vuc0RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICBjYWNoZWRUb2tlbnM6IGNhY2hlZElucHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29tcGxldGlvblRva2VucyA9IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1Rva2VucyA9IChfYiA9IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF9iIDogMDtcbiAgICAgICAgICAgICAgICB1c2FnZS5yZWFzb25pbmdUb2tlbnMgPSByZWFzb25pbmdUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLmNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgICAgcmVhc29uaW5nVG9rZW5zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29zdCA9IHZhbHVlLnVzYWdlLmNvc3Q7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS50b3RhbFRva2VucyA9IHZhbHVlLnVzYWdlLnRvdGFsX3Rva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNob2ljZSA9IHZhbHVlLmNob2ljZXNbMF07XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmZpbmlzaF9yZWFzb24pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmRlbHRhKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gY2hvaWNlLmRlbHRhO1xuICAgICAgICAgICAgY29uc3QgZW1pdFJlYXNvbmluZ0NodW5rID0gKGNodW5rVGV4dCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXJlYXNvbmluZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdJZCA9IG9wZW5yb3V0ZXJSZXNwb25zZUlkIHx8IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIGlkOiByZWFzb25pbmdJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICBkZWx0YTogY2h1bmtUZXh0LFxuICAgICAgICAgICAgICAgIGlkOiByZWFzb25pbmdJZCB8fCBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRlbHRhLnJlYXNvbmluZ19kZXRhaWxzICYmIGRlbHRhLnJlYXNvbmluZ19kZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXRhaWwgb2YgZGVsdGEucmVhc29uaW5nX2RldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRldGFpbC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWwudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGVtaXRSZWFzb25pbmdDaHVuayhkZXRhaWwudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLmVuY3J5cHRlZFwiIC8qIEVuY3J5cHRlZCAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0UmVhc29uaW5nQ2h1bmsoXCJbUkVEQUNURURdXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy5zdW1tYXJ5XCIgLyogU3VtbWFyeSAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLnN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0UmVhc29uaW5nQ2h1bmsoZGV0YWlsLnN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5yZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgZW1pdFJlYXNvbmluZ0NodW5rKGRlbHRhLnJlYXNvbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nU3RhcnRlZCAmJiAhdGV4dFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcmVhc29uaW5nSWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhc29uaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGV4dFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0SWQgPSBvcGVucm91dGVyUmVzcG9uc2VJZCB8fCBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IHRleHRJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBkZWx0YS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGlkOiB0ZXh0SWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBkZWx0YS5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uLnR5cGUgPT09IFwidXJsX2NpdGF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBhbm5vdGF0aW9uLnVybF9jaXRhdGlvbi51cmwsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udXJsLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhbm5vdGF0aW9uLnVybF9jaXRhdGlvbi5jb250ZW50IHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhLnRvb2xfY2FsbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgZGVsdGEudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKF9jID0gdG9vbENhbGxEZWx0YS5pbmRleCkgIT0gbnVsbCA/IF9jIDogdG9vbENhbGxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsc1tpbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsRGVsdGEudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdmdW5jdGlvbicgdHlwZS5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsRGVsdGEuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b29sQ2FsbERlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAnaWQnIHRvIGJlIGEgc3RyaW5nLmBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZCA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5uYW1lKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdmdW5jdGlvbi5uYW1lJyB0byBiZSBhIHN0cmluZy5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsRGVsdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiAoX2UgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uLmFyZ3VtZW50cykgIT0gbnVsbCA/IF9lIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsMiA9IHRvb2xDYWxsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZiA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWUpICE9IG51bGwgJiYgKChfZyA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmFyZ3VtZW50cykgIT0gbnVsbCAmJiBpc1BhcnNhYmxlSnNvbih0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbDIuaW5wdXRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiB0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwyLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwyLnNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG9vbENhbGwuaW5wdXRTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5pbnB1dFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfaCA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyArPSAoX2ogPSAoX2kgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKSAhPSBudWxsID8gX2ogOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBkZWx0YTogKF9rID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbi5hcmd1bWVudHMpICE9IG51bGwgPyBfayA6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoKChfbCA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wubmFtZSkgIT0gbnVsbCAmJiAoKF9tID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbS5hcmd1bWVudHMpICE9IG51bGwgJiYgaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogKF9uID0gdG9vbENhbGwuaWQpICE9IG51bGwgPyBfbiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ExNjtcbiAgICAgICAgICAgIGlmIChmaW5pc2hSZWFzb24gPT09IFwidG9vbC1jYWxsc1wiKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsICYmICF0b29sQ2FsbC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiAoX2ExNiA9IHRvb2xDYWxsLmlkKSAhPSBudWxsID8gX2ExNiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSBpbnZhbGlkIGFyZ3VtZW50cyB0byBhbiBlbXB0eSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSA/IHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA6IFwie31cIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFzb25pbmdTdGFydGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHJlYXNvbmluZ0lkIHx8IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0U3RhcnRlZCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBpZDogdGV4dElkIHx8IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZW5yb3V0ZXJNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgdXNhZ2U6IG9wZW5yb3V0ZXJVc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJNZXRhZGF0YS5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG9wZW5yb3V0ZXI6IG9wZW5yb3V0ZXJNZXRhZGF0YVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgcmVxdWVzdDogeyBib2R5OiBhcmdzIH0sXG4gICAgICByZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wbGV0aW9uL2NvbnZlcnQtdG8tb3BlbnJvdXRlci1jb21wbGV0aW9uLXByb21wdC50c1xuZnVuY3Rpb24gY29udmVydFRvT3BlblJvdXRlckNvbXBsZXRpb25Qcm9tcHQoe1xuICBwcm9tcHQsXG4gIGlucHV0Rm9ybWF0LFxuICB1c2VyID0gXCJ1c2VyXCIsXG4gIGFzc2lzdGFudCA9IFwiYXNzaXN0YW50XCJcbn0pIHtcbiAgaWYgKGlucHV0Rm9ybWF0ID09PSBcInByb21wdFwiICYmIHByb21wdC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdICYmIHByb21wdFswXS5yb2xlID09PSBcInVzZXJcIiAmJiBwcm9tcHRbMF0uY29udGVudC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdLmNvbnRlbnRbMF0gJiYgcHJvbXB0WzBdLmNvbnRlbnRbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyBwcm9tcHQ6IHByb21wdFswXS5jb250ZW50WzBdLnRleHQgfTtcbiAgfVxuICBsZXQgdGV4dCA9IFwiXCI7XG4gIGlmIChwcm9tcHRbMF0gJiYgcHJvbXB0WzBdLnJvbGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICB0ZXh0ICs9IGAke3Byb21wdFswXS5jb250ZW50fVxuXG5gO1xuICAgIHByb21wdCA9IHByb21wdC5zbGljZSgxKTtcbiAgfVxuICBmb3IgKGNvbnN0IHsgcm9sZSwgY29udGVudCB9IG9mIHByb21wdCkge1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkIHN5c3RlbSBtZXNzYWdlIGluIHByb21wdDogJHtjb250ZW50fWAsXG4gICAgICAgICAgcHJvbXB0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImZpbGUgYXR0YWNobWVudHNcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke3VzZXJ9OlxuJHt1c2VyTWVzc2FnZX1cblxuYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IGNvbnRlbnQubWFwKFxuICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sLWNhbGwgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbC1yZXN1bHQgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInJlYXNvbmluZyBtZXNzYWdlc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImZpbGUgYXR0YWNobWVudHNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke2Fzc2lzdGFudH06XG4ke2Fzc2lzdGFudE1lc3NhZ2V9XG5cbmA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbCBtZXNzYWdlc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuYDtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHQ6IHRleHRcbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBsZXRpb24vc2NoZW1hcy50c1xuaW1wb3J0IHsgeiBhcyB6NiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hID0gejYudW5pb24oW1xuICB6Ni5vYmplY3Qoe1xuICAgIGlkOiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIG1vZGVsOiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNob2ljZXM6IHo2LmFycmF5KFxuICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgdGV4dDogejYuc3RyaW5nKCksXG4gICAgICAgIHJlYXNvbmluZzogejYuc3RyaW5nKCkubnVsbGlzaCgpLm9wdGlvbmFsKCksXG4gICAgICAgIHJlYXNvbmluZ19kZXRhaWxzOiBSZWFzb25pbmdEZXRhaWxBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgIGZpbmlzaF9yZWFzb246IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgaW5kZXg6IHo2Lm51bWJlcigpLm51bGxpc2goKSxcbiAgICAgICAgbG9ncHJvYnM6IHo2Lm9iamVjdCh7XG4gICAgICAgICAgdG9rZW5zOiB6Ni5hcnJheSh6Ni5zdHJpbmcoKSksXG4gICAgICAgICAgdG9rZW5fbG9ncHJvYnM6IHo2LmFycmF5KHo2Lm51bWJlcigpKSxcbiAgICAgICAgICB0b3BfbG9ncHJvYnM6IHo2LmFycmF5KHo2LnJlY29yZCh6Ni5zdHJpbmcoKSwgejYubnVtYmVyKCkpKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxhYmxlKCkub3B0aW9uYWwoKVxuICAgICAgfSlcbiAgICApLFxuICAgIHVzYWdlOiB6Ni5vYmplY3Qoe1xuICAgICAgcHJvbXB0X3Rva2VuczogejYubnVtYmVyKCksXG4gICAgICBwcm9tcHRfdG9rZW5zX2RldGFpbHM6IHo2Lm9iamVjdCh7XG4gICAgICAgIGNhY2hlZF90b2tlbnM6IHo2Lm51bWJlcigpXG4gICAgICB9KS5udWxsaXNoKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogejYubnVtYmVyKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzOiB6Ni5vYmplY3Qoe1xuICAgICAgICByZWFzb25pbmdfdG9rZW5zOiB6Ni5udW1iZXIoKVxuICAgICAgfSkubnVsbGlzaCgpLFxuICAgICAgdG90YWxfdG9rZW5zOiB6Ni5udW1iZXIoKSxcbiAgICAgIGNvc3Q6IHo2Lm51bWJlcigpLm9wdGlvbmFsKClcbiAgICB9KS5udWxsaXNoKClcbiAgfSksXG4gIE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hXG5dKTtcblxuLy8gc3JjL2NvbXBsZXRpb24vaW5kZXgudHNcbnZhciBPcGVuUm91dGVyQ29tcGxldGlvbkxhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIHNldHRpbmdzLCBjb25maWcpIHtcbiAgICB0aGlzLnNwZWNpZmljYXRpb25WZXJzaW9uID0gXCJ2MlwiO1xuICAgIHRoaXMucHJvdmlkZXIgPSBcIm9wZW5yb3V0ZXJcIjtcbiAgICB0aGlzLnN1cHBvcnRlZFVybHMgPSB7XG4gICAgICBcImltYWdlLypcIjogW1xuICAgICAgICAvXmRhdGE6aW1hZ2VcXC9bYS16QS1aXSs7YmFzZTY0LC8sXG4gICAgICAgIC9eaHR0cHM/OlxcL1xcLy4rXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8d2VicCkkL2lcbiAgICAgIF0sXG4gICAgICBcInRleHQvKlwiOiBbL15kYXRhOnRleHRcXC8vLCAvXmh0dHBzPzpcXC9cXC8uKyQvXSxcbiAgICAgIFwiYXBwbGljYXRpb24vKlwiOiBbL15kYXRhOmFwcGxpY2F0aW9uXFwvLywgL15odHRwcz86XFwvXFwvLiskL11cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIHByb21wdCxcbiAgICBtYXhPdXRwdXRUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgdG9wUCxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIHJlc3BvbnNlRm9ybWF0LFxuICAgIHRvcEssXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlXG4gIH0pIHtcbiAgICBjb25zdCB7IHByb21wdDogY29tcGxldGlvblByb21wdCB9ID0gY29udmVydFRvT3BlblJvdXRlckNvbXBsZXRpb25Qcm9tcHQoe1xuICAgICAgcHJvbXB0LFxuICAgICAgaW5wdXRGb3JtYXQ6IFwicHJvbXB0XCJcbiAgICB9KTtcbiAgICBpZiAodG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sc1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRvb2xDaG9pY2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbENob2ljZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsczogdGhpcy5zZXR0aW5ncy5tb2RlbHMsXG4gICAgICAvLyBtb2RlbCBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGxvZ2l0X2JpYXM6IHRoaXMuc2V0dGluZ3MubG9naXRCaWFzLFxuICAgICAgbG9ncHJvYnM6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcIm51bWJlclwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcImJvb2xlYW5cIiA/IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPyAwIDogdm9pZCAwIDogdm9pZCAwLFxuICAgICAgc3VmZml4OiB0aGlzLnNldHRpbmdzLnN1ZmZpeCxcbiAgICAgIHVzZXI6IHRoaXMuc2V0dGluZ3MudXNlcixcbiAgICAgIC8vIHN0YW5kYXJkaXplZCBzZXR0aW5nczpcbiAgICAgIG1heF90b2tlbnM6IG1heE91dHB1dFRva2VucyxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgdG9wX3A6IHRvcFAsXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgIHNlZWQsXG4gICAgICBzdG9wOiBzdG9wU2VxdWVuY2VzLFxuICAgICAgcmVzcG9uc2VfZm9ybWF0OiByZXNwb25zZUZvcm1hdCxcbiAgICAgIHRvcF9rOiB0b3BLLFxuICAgICAgLy8gcHJvbXB0OlxuICAgICAgcHJvbXB0OiBjb21wbGV0aW9uUHJvbXB0LFxuICAgICAgLy8gT3BlblJvdXRlciBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGluY2x1ZGVfcmVhc29uaW5nOiB0aGlzLnNldHRpbmdzLmluY2x1ZGVSZWFzb25pbmcsXG4gICAgICByZWFzb25pbmc6IHRoaXMuc2V0dGluZ3MucmVhc29uaW5nXG4gICAgfSwgdGhpcy5jb25maWcuZXh0cmFCb2R5KSwgdGhpcy5zZXR0aW5ncy5leHRyYUJvZHkpO1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUob3B0aW9ucykge1xuICAgIHZhciBfYTE1LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX287XG4gICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gb3B0aW9ucy5wcm92aWRlck9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgb3BlbnJvdXRlck9wdGlvbnMgPSBwcm92aWRlck9wdGlvbnMub3BlbnJvdXRlciB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0QXJncyhvcHRpb25zKSksIG9wZW5yb3V0ZXJPcHRpb25zKTtcbiAgICBjb25zdCB7IHZhbHVlOiByZXNwb25zZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5yb3V0ZXJGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBpZiAoXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2UuZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hvaWNlID0gcmVzcG9uc2UuY2hvaWNlc1swXTtcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hvaWNlIGluIE9wZW5Sb3V0ZXIgY29tcGxldGlvbiByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IChfYTE1ID0gY2hvaWNlLnRleHQpICE9IG51bGwgPyBfYTE1IDogXCJcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZmluaXNoUmVhc29uOiBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKSxcbiAgICAgIHVzYWdlOiB7XG4gICAgICAgIGlucHV0VG9rZW5zOiAoX2MgPSAoX2IgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYyA6IDAsXG4gICAgICAgIG91dHB1dFRva2VuczogKF9lID0gKF9kID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jb21wbGV0aW9uX3Rva2VucykgIT0gbnVsbCA/IF9lIDogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6ICgoX2cgPSAoX2YgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfZyA6IDApICsgKChfaSA9IChfaCA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2guY29tcGxldGlvbl90b2tlbnMpICE9IG51bGwgPyBfaSA6IDApLFxuICAgICAgICByZWFzb25pbmdUb2tlbnM6IChfbCA9IChfayA9IChfaiA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ouY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLnJlYXNvbmluZ190b2tlbnMpICE9IG51bGwgPyBfbCA6IDAsXG4gICAgICAgIGNhY2hlZElucHV0VG9rZW5zOiAoX28gPSAoX24gPSAoX20gPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tLnByb21wdF90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmNhY2hlZF90b2tlbnMpICE9IG51bGwgPyBfbyA6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuaW5nczogW10sXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGRvU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSBvcHRpb25zLnByb3ZpZGVyT3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBvcGVucm91dGVyT3B0aW9ucyA9IHByb3ZpZGVyT3B0aW9ucy5vcGVucm91dGVyIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5nZXRBcmdzKG9wdGlvbnMpKSwgb3BlbnJvdXRlck9wdGlvbnMpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHJlc3BvbnNlLCByZXNwb25zZUhlYWRlcnMgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXJncyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgc3RyZWFtX29wdGlvbnMgd2hlbiBpbiBzdHJpY3QgY29tcGF0aWJpbGl0eSBtb2RlOlxuICAgICAgICBzdHJlYW1fb3B0aW9uczogdGhpcy5jb25maWcuY29tcGF0aWJpbGl0eSA9PT0gXCJzdHJpY3RcIiA/IHsgaW5jbHVkZV91c2FnZTogdHJ1ZSB9IDogdm9pZCAwXG4gICAgICB9KSxcbiAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogb3BlbnJvdXRlckZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgaW5wdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBvdXRwdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICB0b3RhbFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBjb25zdCBvcGVucm91dGVyVXNhZ2UgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ExNSwgX2I7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiB2YWx1ZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXNhZ2UuaW5wdXRUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICAgICAgICB1c2FnZS5vdXRwdXRUb2tlbnMgPSB2YWx1ZS51c2FnZS5jb21wbGV0aW9uX3Rva2VucztcbiAgICAgICAgICAgICAgdXNhZ2UudG90YWxUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zICsgdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5wcm9tcHRUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkSW5wdXRUb2tlbnMgPSAoX2ExNSA9IHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscy5jYWNoZWRfdG9rZW5zKSAhPSBudWxsID8gX2ExNSA6IDA7XG4gICAgICAgICAgICAgICAgdXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMgPSBjYWNoZWRJbnB1dFRva2VucztcbiAgICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UucHJvbXB0VG9rZW5zRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlZFRva2VuczogY2FjaGVkSW5wdXRUb2tlbnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5jb21wbGV0aW9uVG9rZW5zID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nVG9rZW5zID0gKF9iID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscy5yZWFzb25pbmdfdG9rZW5zKSAhPSBudWxsID8gX2IgOiAwO1xuICAgICAgICAgICAgICAgIHVzYWdlLnJlYXNvbmluZ1Rva2VucyA9IHJlYXNvbmluZ1Rva2VucztcbiAgICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29tcGxldGlvblRva2Vuc0RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICByZWFzb25pbmdUb2tlbnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5jb3N0ID0gdmFsdWUudXNhZ2UuY29zdDtcbiAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLnRvdGFsVG9rZW5zID0gdmFsdWUudXNhZ2UudG90YWxfdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hvaWNlID0gdmFsdWUuY2hvaWNlc1swXTtcbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UuZmluaXNoX3JlYXNvbikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UudGV4dCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBjaG9pY2UudGV4dCxcbiAgICAgICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG9wZW5yb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBvcGVucm91dGVyVXNhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZmFjYWRlLnRzXG52YXIgT3BlblJvdXRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT3BlblJvdXRlciBwcm92aWRlciBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTE1LCBfYjtcbiAgICB0aGlzLmJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaCgoX2ExNSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hMTUgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjFcIjtcbiAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgfVxuICBnZXQgYmFzZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZVVSTDogdGhpcy5iYXNlVVJMLFxuICAgICAgaGVhZGVyczogKCkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7bG9hZEFwaUtleSh7XG4gICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZTogXCJPUEVOUk9VVEVSX0FQSV9LRVlcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJPcGVuUm91dGVyXCJcbiAgICAgICAgfSl9YFxuICAgICAgfSwgdGhpcy5oZWFkZXJzKVxuICAgIH07XG4gIH1cbiAgY2hhdChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBPcGVuUm91dGVyQ2hhdExhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbnJvdXRlci5jaGF0XCJcbiAgICB9LCB0aGlzLmJhc2VDb25maWcpLCB7XG4gICAgICBjb21wYXRpYmlsaXR5OiBcInN0cmljdFwiLFxuICAgICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke3RoaXMuYmFzZVVSTH0ke3BhdGh9YFxuICAgIH0pKTtcbiAgfVxuICBjb21wbGV0aW9uKG1vZGVsSWQsIHNldHRpbmdzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE9wZW5Sb3V0ZXJDb21wbGV0aW9uTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBwcm92aWRlcjogXCJvcGVucm91dGVyLmNvbXBsZXRpb25cIlxuICAgIH0sIHRoaXMuYmFzZUNvbmZpZyksIHtcbiAgICAgIGNvbXBhdGliaWxpdHk6IFwic3RyaWN0XCIsXG4gICAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7dGhpcy5iYXNlVVJMfSR7cGF0aH1gXG4gICAgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZU9wZW5Sb3V0ZXIob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTE1LCBfYiwgX2M7XG4gIGNvbnN0IGJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaCgoX2ExNSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hMTUgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjFcIjtcbiAgY29uc3QgY29tcGF0aWJpbGl0eSA9IChfYyA9IG9wdGlvbnMuY29tcGF0aWJpbGl0eSkgIT0gbnVsbCA/IF9jIDogXCJjb21wYXRpYmxlXCI7XG4gIGNvbnN0IGdldEhlYWRlcnMgPSAoKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2xvYWRBcGlLZXkoe1xuICAgICAgYXBpS2V5OiBvcHRpb25zLmFwaUtleSxcbiAgICAgIGVudmlyb25tZW50VmFyaWFibGVOYW1lOiBcIk9QRU5ST1VURVJfQVBJX0tFWVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiT3BlblJvdXRlclwiXG4gICAgfSl9YFxuICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBjcmVhdGVDaGF0TW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5Sb3V0ZXJDaGF0TGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXIuY2hhdFwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICBleHRyYUJvZHk6IG9wdGlvbnMuZXh0cmFCb2R5XG4gIH0pO1xuICBjb25zdCBjcmVhdGVDb21wbGV0aW9uTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5Sb3V0ZXJDb21wbGV0aW9uTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXIuY29tcGxldGlvblwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICBleHRyYUJvZHk6IG9wdGlvbnMuZXh0cmFCb2R5XG4gIH0pO1xuICBjb25zdCBjcmVhdGVMYW5ndWFnZU1vZGVsID0gKG1vZGVsSWQsIHNldHRpbmdzKSA9PiB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgT3BlblJvdXRlciBtb2RlbCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBrZXl3b3JkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZWxJZCA9PT0gXCJvcGVuYWkvZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcGxldGlvbk1vZGVsKFxuICAgICAgICBtb2RlbElkLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYXRNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIGNvbnN0IHByb3ZpZGVyID0gKG1vZGVsSWQsIHNldHRpbmdzKSA9PiBjcmVhdGVMYW5ndWFnZU1vZGVsKG1vZGVsSWQsIHNldHRpbmdzKTtcbiAgcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbCA9IGNyZWF0ZUxhbmd1YWdlTW9kZWw7XG4gIHByb3ZpZGVyLmNoYXQgPSBjcmVhdGVDaGF0TW9kZWw7XG4gIHByb3ZpZGVyLmNvbXBsZXRpb24gPSBjcmVhdGVDb21wbGV0aW9uTW9kZWw7XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbnZhciBvcGVucm91dGVyID0gY3JlYXRlT3BlblJvdXRlcih7XG4gIGNvbXBhdGliaWxpdHk6IFwic3RyaWN0XCJcbiAgLy8gc3RyaWN0IGZvciBPcGVuUm91dGVyIEFQSVxufSk7XG5leHBvcnQge1xuICBPcGVuUm91dGVyLFxuICBjcmVhdGVPcGVuUm91dGVyLFxuICBvcGVucm91dGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@openrouter+ai-sdk-provider_cc067f969ca6f2d6fe755f9c943e4cee/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs\n");

/***/ })

};
;